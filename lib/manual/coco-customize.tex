\begin{Heading}{chapter}
  \Title{Custom Containers}
  \RefLabel{chap:customize}
\end{Heading}


As we already discussed in chapter~\ref{chap:overview},
Containers\Index{Container} are representations of typographical
elements that share a more or less fixed set of components that are
supposed to be rendered in a similar way.

In this section, we discuss how to declare custom Containers.

A new, custom Container can be declared with the
\DeclareMacro{\ccDeclareContainer} command:
\begin{lstlisting}
\ccDeclareContainer{<name>}{<body>}
\end{lstlisting}
where \lstinline{<name>} is the name of the Container, and
\lstinline{<body>} is a list of Container Type Declarations.

Data Types are declared with the \DeclareMacro{\ccDeclareType} command:
\begin{lstlisting}
\ccDeclareType{<name>}{<body>}
\end{lstlisting}
where \lstinline{<name>} is the name of the Data Type, and
\lstinline{<body>} a list of type-specific variable declarations. The
most commonly used Data Types are \textit{Properties},
\textit{Attributes}, and \textit{Components}, but essentially, they
can be named anything.

Another common command inside the Container body is the
\DeclareMacro{\ccInherit} command. It takes two arguments:
\InlineArg{1} is a~comma-separated list of Data Types, and
\lstinline{2}~is a~comma-separated list of Container names. The newly
defined Contianer will then inherit all Data Type declarations from
the parent Containers. For instance,
\begin{lstlisting}
\ccDeclareContainer{Parent 1}{%
  \ccDeclareType{Properties}{...}%
  \ccDeclareType{Components}{...}%
  \ccDeclareType{Junk}{...}%
}
\ccDeclareContainer{Parent 2}{%
  \ccDeclareType{Properties}{...}%
  \ccDeclareType{Components}{...}%
}
\ccDeclareContainer{Child}{%
  \ccInherit{Properties,Components}{Parent 1,Parent 2}%
}
\end{lstlisting}
means that the Container named \lstinline{Child} will inherit the
\textit{Components} and \textit{Properties} Data Types from both
Containers \lstinline{Parent 1} and \lstinline{Parent 2},
respectively, but not the Data Type \lstinline{Junk} from \lstinline{Parent 1}.

Note that both \UsageMacro{\ccDeclareType} and \UsageMacro{\ccInherit}
can only be used inside the body of a Container Declaration!











Sometimes, it is neccessary to check whether a Property yields any
Content, at all. This can be done with the macro
\DescribeMacro{\ccIfProp}, which takes three arguments:
\begin{ArgList}
\item[1] the name of the Property
\item[2] code that is executed when the Property exists and yields a
  non-empty string
\item[3] code that is executed when either the Property does not exist
  or if yields an empty string
\end{ArgList}
An example could be:
\begin{lstlisting}
\ccSetProperty{}{}
\end{lstlisting}

Some Properties have pre-defined values. To check for a~given value,
the macro \DescribeMacro{\ccIfPropVal} can be used. It has four
arguments:
\begin{ArgList}
\item[1] the name of the Property
\item[2] the string to compare the Property's expansion against
\item[3] code that is executed when the Property's expansion matches
  \InlineArg{2}
\item[4] code that is expanded when either the Property does not exist
  or its expansion value does not match \DescribeMacro{2}.
\end{ArgList}
\begin{Warning}
  Since Properties are LaTeX macros that are always defined
  \lstinline{\long}, the comparison value \InlineArg2 is also stored
  in a~temporary macro using \lstinline{\long\def}. Therefore,
  \lstinline{\ccIfPropVal} cannot be used in contexts that fully
  expand the Property list, in particular
  \UsageMacro{\ccApplyCollection}!
\end{Warning}
