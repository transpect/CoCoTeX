% \chapter{coco-lists.dtx}\DescriptionDomain{List}
%    \begin{macrocode}[numbers=none,gobble=1]
%<*lists>
%    \end{macrocode}
%
% This module provides handlers for list-like environments like item
% lists, enumerations, glossaries and descriptions.
%
% \textbf{Note:} The \lstinline{coco-lists} module diverges somewhat
% from the other {\CoCoTeX} modules insofar as that its main Container
% does not follow the \CoCoTeX's usual ``collect all--process later''
% approach, but all Properties are processed at the beginning of each
% Container's instances and the contents are processed as they are
% parsed by the \lstinline{\LaTeX} interpreter, just like ``reguar''
% {\LaTeX} lists. Configuration of lists, however, follows the
% {\CoCoTeX} playbook.
%
% \section{Preamble}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2018/12/01]
\ProvidesPackage{coco-lists}
    [\filedate \fileversion CoCoTeX lists module]
\RequirePackage{coco-common}
%    \end{macrocode}
%
%
% \subsection{Package Options}\label{sec:coco-lists:options}
%
% If the \lstinline{replace} option is set, LaTeX's default lists are
% replaced by \lstinline{coco-lists} module. This effects \LaTeX's
% \MacroString{enumerate}, \MacroString{itemize}, and
% \MacroString{description} environments.
%    \begin{macrocode}
\newif\if@ccl@replace \@ccl@replacefalse
\DeclareOptionX{replace}{\global\@ccl@replacetrue}%
%    \end{macrocode}
% The option inherit defines how nested lists inherit their
% properties. Currently, there are two ways: \lstinline{common}: All
% nested lists of the same type inherit only from the same, generic
% type definition; \lstinline{conseq}: nested lists of the same type
% inherit from the next-higher level list of the same type, and from
% the generic type definition.
%
% For example, if \lstinline{inherit=common}, 3rd level
% \MacroString{itemize} and 2nd level \MacroString{itemize} both inherit
% only the property values of the same generic \MacroString{itemize}
% list type. If \lstinline{inherit=conseq}, 3rd level inherits the
% property lists from 2nd level \MacroString{itemize}.
%
% Since inheritance is a transitive relation, 3rd level
% \MacroString{itemize} will ultimately also inherit the Properties from
% generic \MacroString{itemize}, but in contrast to \lstinline{common},
% \lstinline{conseq} allows 2nd level \MacroString{itemize} to override
% some Properties of generic \MacroString{itemize}, which will be
% propagate down to 3rd level \MacroString{itemize}, while with
% \lstinline{inherit=common}, the override on 2nd level
% \MacroString{itemize} would have no effect on 3rd level
% \MacroString{itemize}.
% \begin{macro}{\ccl@ih@common} is used for comparisons. It represents
%   the \lstinline{inherit=common} package option.
%    \begin{macrocode}
\def\ccl@ih@common{common}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@ih@conseq} is used for comparisons. It represents
%   the \lstinline{inherit=conseq} package option.
%    \begin{macrocode}
\def\ccl@ih@conseq{conseq}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@str@local} is a string for comparison. It
%   represents the \lstinline{nesting=local} option.
%    \begin{macrocode}
\def\ccl@str@local{local}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@str@global} is a string for comparison. It
%   represents the \lstinline{nesting=global} option.
%    \begin{macrocode}
\def\ccl@str@global{global}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@inherit} stores the value of the
%   \lstinline{inherit} package option.
%    \begin{macrocode}
\let\ccl@inherit\ccl@ih@common
\define@choicekey{coco-lists.sty}{inherit}[\@ccl@inherit\nr]{conseq,common}{%
  \ifcase\nr\relax% conseq: nested lists of the same type inherit only from the previous level
    \global\let\ccl@inherit\ccl@ih@conseq
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@nesting} The nesting option sets whether the
%   nesting level of a list should be counted list-specific (value
%   \lstinline{local}), or globally (value \lstinline{global},
%   default).
%    \begin{macrocode}
\let\ccl@nesting\ccl@str@global
\define@choicekey{coco-lists.sty}{nesting}[\@ccl@nesting\nr]{local,global}{%
  \ifcase\nr\relax% local
    \global\let\ccl@nesting\ccl@str@local
  \fi
}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\ProcessOptionsX
%    \end{macrocode}
%
% \section{The List Container}
%
% \DescribeContainer{List} is the most abstract Container for lists.
%    \begin{macrocode}
\ccDeclareContainer{List}{%
%    \end{macrocode}
%
% \subsection{List Properties}
%
%    \begin{macrocode}
  \ccDeclareType{Properties}{%
%    \end{macrocode}
%
% \subsubsection{List Boundaries}
%
% \begin{Property}{before-list}{<any>} is expanded at the very
%   beginning of a (nested) list.
%    \begin{macrocode}
    \ccSetProperty{before-list}{% at the very beginning of each (nested) list
      \if@noskipsec \leavevmode \fi
      \ifvmode\else
        \unskip \par
      \fi
%    \end{macrocode}
%   \DescribeTagS{L} is the opening List tag
%    \begin{macrocode}
      \ccaStructStart{L}%
    }%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{after-list}{<any>} is expanded at the very end of a
%   (nested) list. By default, it calls the \UsageProp{after-item}
%   Property.  \DescribeTagE{L} is the closing List tag
%    \begin{macrocode}
    \ccSetProperty{after-list}{%
      \ccUseProperty{after-item}%
      \ccaStructEnd{L}% end tag for the (nested) list
    }%
%    \end{macrocode}
% \end{Property}
%
% \subsubsection{List Margins}
%
% \begin{Property}{margin-top}{<skip>} is the vertical skip at the
%   beginning of each List instance.
%    \begin{macrocode}
    %% list margins
    \ccSetProperty{margin-top}{\z@}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{margin-bottom}{<skip>} is the vertical skip at the
%   end of each List instance.
%    \begin{macrocode}
    \ccSetProperty{margin-bottom}{\z@}% vertical space before the list.
%    \end{macrocode}
% \end{Property}
% \begin{Property}{margin-left}{[auto|<skip>]} is the horizontal space
%   to the left of each list instance, from left boundary of the page
%   area.  \lstinline{auto} means that the left margin is set to the
%   width of widest label + \UsageProp{prev-margin-left}. The value is
%   passed through \lstinline{\dimexpr}, so basic arithmatic is
%   allowed.
%    \begin{macrocode}
    \ccSetProperty{margin-left}{\csname leftmargin\@roman\cclCurDepth\endcsname-\ccUseProperty{label-sep}+\ccUseProperty{prev-margin-left}}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{max-label-width}{<dimen>} is the maximum space reserved
%   for a list item's label.
%    \begin{macrocode}
    \ccSetProperty{max-label-width}{.33\textwidth}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{margin-right}{<skip>} is the right margin of the
%   list instance.
%    \begin{macrocode}
    \ccSetProperty{margin-right}{\z@}% horizontal space to the right of each list item
%    \end{macrocode}
% \end{Property}
%
% \subsubsection{Between List Items}
%
% \begin{Property}{item-sep}{<skip>} is the \textit{vertical} space
%   between two adjacent list items. Note that the real value value is
%   advanced by the value of the \UsageProp{par-skip} Property.
%    \begin{macrocode}
    \ccSetProperty{item-sep}{\z@}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{after-indent}{[true|false]} determins whether the
%   text paragraph after the (top-level) list is indented
%   (\lstinline{true}) or not (\lstinline{false}).
%    \begin{macrocode}
    \ccSetProperty{after-indent}{false}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{at-begin-item-body}{<any>} is expanded right at the
%   beginning of a new item body and sets the \DescribeTagS{LBody}
%   tag.
%    \begin{macrocode}
    \ccSetProperty{at-begin-item-body}{\ccaVstructStart{LBody}}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{at-end-item-body}{<any>} is expanded at the very
%   end of an item body, but before the final \lstinline{\par}. By
%   default, it only sets the closing \DescribeTagE{LBody} tag.
%    \begin{macrocode}
    \ccSetProperty{at-end-item-body}{\ccaVstructEnd{LBody}}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{after-item}{<any>} is expanded after each list
%   item. It calls the \UsageProp{at-end-item-body} Property and
%   closes the item's final paragraph as well as the \DescribeTagE{LI}
%   tag.
%    \begin{macrocode}
    \ccSetProperty{after-item}{%
      \ccUseProperty{at-end-item-body}%
      \ccaVstructEnd{LI}% Close list item tags
      \par}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{before-item}{<any>} is called at the very beginning
%   of each list item. If the current item is the first item, the
%   \UsageMacro{\ifcclFirst} conditional is set to false. All
%     non-first items of the same List instance call the
%     \UsageProp{after-item} Property and add a vertical skip of
%     \UsageProp{item-sep} amount.
%
%     After that, the paragraph formatting parameters for the
%     list-item \UsageProp{par-indent}, \UsageProp{par-skip}, and
%     \UsageProp{par-fill-skip}, as well as the starting
%     \DescribeTagS{LI} tag are set.
%    \begin{macrocode}
    \ccSetProperty{before-item}{%
      \ifcclFirst
        \global\cclFirstfalse
      \else
        \ccUseProperty{after-item}%
        \vskip\ccUseProperty{item-sep}%
      \fi
      \parindent\ccUseProperty{par-indent}\relax%
      \parskip\ccUseProperty{par-skip}\relax%
      \parfillskip\ccUseProperty{par-fill-skip}\relax%
      \noindent
      \leavevmode
      \ccaVstructStart{LI}% Start tag for a list item
    }%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{item-offset}{<any>} calculates
%   \UsageMacro{\cclItemIndent} from the \UsageProp{indent} and
%   \UsageProp{label-sep} Properties and sets the horizontal offset of
%   the first line of the list item. After that, the value of the
%   macro is unsigned.
%    \begin{macrocode}
    \ccSetProperty{item-offset}{%
      \cclItemIndent\ccUseProperty{indent}%
      \advance\cclItemIndent\dimexpr-\ccUseProperty{label-sep}\relax
      \hskip\cclItemIndent\relax%
      \ifdim\ccUseProperty{indent}>\z@
        \cclItemIndent\ccUseProperty{indent}%
      \else
        \cclItemIndent-\ccUseProperty{indent}%
      \fi
    }%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{par-indent}{<skip>} is the indent of the first line
%   of a *new* paragraph inside a list item
%    \begin{macrocode}
    \ccSetProperty{par-indent}{\parindent}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{par-fill-skip}{<skip>} is the skip at the end of
%   the last line of each paragraph inside a list item
%    \begin{macrocode}
    \ccSetProperty{par-fill-skip}{\@flushglue}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{par-skip}{<dimen>} vertical space between two
%   adjacent paragraphs inside the same List item
%    \begin{macrocode}
    \ccSetProperty{par-skip}{\z@}%
%    \end{macrocode}
% \end{Property}
%
% \subsubsection{Label Formatting}
%
% \begin{Property}{label}{<any>} prints the \UsageComponent{Label}
%   component.
%    \begin{macrocode}
    \ccSetProperty{label}{\ccUseComp{Label}}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{indent}{[auto|auto-global|<dimen>]} is the indent
%   of each List item's first line (relative to
%   \UsageProp{margin-left}).
%
%   If the value is \lstinline{auto}, the real indent and left margin
%   of a item's first line is calculated using coco-common's
%   indentation mechanism (see Sect.~\ref{sec:indent} in
%   Module~\ref{chap:common}). The first-line indent will thereby be
%   calculated from the widest width of all labels of the same list
%   type and nesting level.
%
%   \textbf{Note:} the value \lstinline{auto-global} is allowed, but
%   it causes *all* lists --~regarless of the nesting level~-- to have
%   the same left margin and indent!
%    \begin{macrocode}
    \ccSetProperty{indent}{-\dimexpr\csname leftmargin\@roman\cclCurDepth\endcsname-\ccUseProperty{label-sep}\relax}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{label-sep}{<dimen>} is the horizontal space between
%   the label and the item body.
%    \begin{macrocode}
    \ccSetProperty{label-sep}{.5em}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{label-face}{<any>} is the style of the label.
%    \begin{macrocode}
    \ccSetProperty{label-face}{}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{label-align}{[left|center|right]} is the alignment
%   of the label within its local \lstinline{\hbox}.
%    \begin{macrocode}
    \ccSetProperty{label-align}{left}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{label-format}{<any>} is the format of the label. It
%   should call the \UsageProp{label-face} and \UsageProp{label}
%   properties and enclose the latter with \DescribeTagS{Lbl} and
%   \DescribeTagE{Lbl}.
%    \begin{macrocode}
    \ccSetProperty{label-format}{%
      \ccUseProperty{label-face}%
      \ccaVstructStart{Lbl}%
      \ccUseProperty{label}%
      \ccaVstructEnd{Lbl}%
    }%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{label-box}{<any>} is the property that builds a
%   local \lstinline{\hbox} into which the \UsageComponent{Label}
%   Component is printed. It should respect the
%   \UsageProp{label-align} Property and call
%   \UsageProp{label-format}.
%    \begin{macrocode}
    \ccSetProperty{label-box}{%
      \hbox to \cclItemIndent{%
        \ccIfPropVal{label-align}{left}{}{\hss}%
        \ccUseProperty{label-format}%
        \ccIfPropVal{label-align}{right}{}{\hss}}%
    }%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{item-format}{<any>} contains material printed at
%   the beginning of a new item. It should call the
%   \UsageProp{before-item}, \UsageProp{item-offset},
%   \UsageProp{label-box} and \UsageProp{label-sep} Properties.
%    \begin{macrocode}
    \ccSetProperty{item-format}{%
      \ccUseProperty{before-item}%
      \ccUseProperty{item-offset}%
      \ccUseProperty{label-box}%
      \hskip\ccUseProperty{label-sep}%
    }%
  }%
%    \end{macrocode}
% \end{Property}
%
% \subsection{List Components}
%
%    \begin{macrocode}
  \ccDeclareType{Components}{%
%    \end{macrocode}
% \begin{Component}{Label} represents a List item's local label.
%    \begin{macrocode}
    \ccDeclareComponent{Label}%
%    \end{macrocode}
% \end{Component}
%    \begin{macrocode}
  }%
  \ccDeclareEnv{cc@list}{endcc@list}%
}
%    \end{macrocode}
%
%
% \section{Declaring List Types}
%
% List Types are the next layer of abstraction for lists. This layer
% distinguishes numbered from unnnumbered and description lists.
%
% \begin{macro}{\DeclareListType} declares a new list type. \#1 is the
%   name of the list type, \#2 is the declaration body. Each new list
%   type should declare at least an Attribute handler and a Label
%   handler. \#3 is a list of type specific properties that are
%   appended to the generic list's property list.
%    \begin{macrocode}
\long\def\ccDeclareListType#1#2#3{%
%    \end{macrocode}
% \begin{macro}{\DeclareAttributeHandler} declares a new handler
%   for a list's attributes. \#\#1 is the definition body.
%    \begin{macrocode}
  \def\DeclareAttributeHandler##1{\csdef{ccl@eval@attrs@#1}{##1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\DeclareLabelHandler} declares a new handler for each
%   item's label.  \#\#1 is the definition body. It should fill the Label Component with content in case the optional  argument of item is omitted.
%    \begin{macrocode}
  \def\DeclareLabelHandler##1{\csdef{ccl@make@label@#1}{##1}}%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
  \ccDeclareContainer{#1List}{%
    \ccInherit{Components,Properties}{List}%
    \ccDeclareType{Properties}{%
%    \end{macrocode}
% \begin{Property}{list-type}{<any>} holds the name of the list type.
%    \begin{macrocode}
      \ccSetProperty{list-type}{#1}%
%    \end{macrocode}
% \end{Property}
%    \begin{macrocode}
      #3%
    }%
    \ccDeclareEnv[#1-list]{\cc@list}{\endcc@list}%
  }%
  #2%
}
%    \end{macrocode}
% \end{macro}
%
%
% \section{Declare Lists}
%
% The next layer of abstraction is the user-level List container. Each
% List container must be assigned to a list type from which it will
% inherit its type-specific properties.
%
% \begin{macro}{\ccDeclareList} defines a new list. \#1 is the name of
%   the list environment (sans \lstinline{\ccPrefix}), \#2 is the list
%   type, \#3 is the list-specific Property list.
%    \begin{macrocode}
\def\ccDeclareList#1#2#3{%
  \csxdef{cc@cur@depth@#1}{\z@}%
  \ccDeclareContainer{#1}{%
    \ccInherit{Properties,Components}{#2List}%
    \ccDeclareType{Properties}{#3}%
    \ccDeclareEnv[#1]{\cc@list}{\endcc@list}%
  }%
  \ccDeclareNested{#1}{\z@}{}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccDeclareNested} can be used to declare Property
%   overrides for nested lists. \#1 is the list name, \#2 is the
%   nesting depth ($\#2$th nesting level means that the Properties are
%   used for the $n+1$-th list of the same name), \#3 is the Property
%   list.
%    \begin{macrocode}
\def\ccDeclareNested#1#2#3{%
  \@tempcnta=#2\relax
  \ifx\@tempcnta<\z@\relax
    \ccPackageError{lists}{Nesting}{Invalid nesting level!}{You cannot declare nesting levels less than 0!}%
  \fi
  \advance\@tempcnta\@ne\relax
  \ccDeclareContainer{#1-\the\@tempcnta}{%
    \ifcsdef{cc@container@#1}
      {\ccInherit{Properties,Components}{#1}}
      {\ccPackageError{lists}{Inheritance}
        {List `#1' undefined!}
        {You need to define the list `#1' before you can declare nested list overrides!}}%
      \ccDeclareType{Properties}{#3}%
    }%
}
%    \end{macrocode}
% \end{macro}
%
% We want to count each list type seperately to ensure the correct
% item label is printed, but we also need to keep within the global
% nesting level limit. Therefore, we set two internal counters, one
% for the overall nesting level, and another one for each list
% type. Note that the latter is a macro, not a counter register.
%
% \begin{macro}{\ccl@depth} is the counter for the overall nesting level.
%    \begin{macrocode}
\newcount\ccl@depth
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@item@cnt} is the internal counter for the items within a (nested) list level.
%    \begin{macrocode}
\newcount\ccl@item@cnt
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ifcclFirst} is true as long as the first item of a
%     list is processed.
%    \begin{macrocode}
\newif\ifcclFirst \cclFirsttrue
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@advance@depth} is a helper macro to advance both
%   the global list nesting level, as well as the list Container
%   specific nesting level. \#1 is the amount by which both counters
%   should be advanced.
%    \begin{macrocode}
\def\ccl@advance@depth#1{\csname ccl@advance@depth@\ccl@nesting\endcsname{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@advance@depth@global} is called when the nesting
%   level should be counted for all lists equally without respecting
%   the list type.
%    \begin{macrocode}
\def\ccl@advance@depth@global#1{%
  \edef\cclPrevDepth{\the\ccl@depth}%
  \global\advance\ccl@depth#1\relax
  \edef\cclCurDepth{\the\ccl@depth}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@advance@depth@local} is called when the nesting
%   level should be counted for each list type individually.
%    \begin{macrocode}
\def\ccl@advance@depth@local#1{%
  \letcs\cclPrevDepth{cc@cur@depth@\cc@cur@cont}%
  \expandafter\@tempcnta\csname cc@cur@depth@\cc@cur@cont\endcsname\relax
  \advance\@tempcnta#1\relax
  \csxdef{cc@cur@depth@\cc@cur@cont}{\the\@tempcnta}%
  \edef\cclCurDepth{\csname cc@cur@depth@\cc@cur@cont\endcsname}%
  \global\advance\ccl@depth#1\relax
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclItemIndent} stores the actual calculated indent of
%   an List item's first line.
%    \begin{macrocode}
\newskip\cclItemIndent
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclTopID} is a counter that stores a unique number
%   for each top-level List Instance. It is used to calculate the
%   margins of both top-level items and items of nested lists.
%    \begin{macrocode}
\newcount\cclTopID       \cclTopID\z@\relax
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclID} stores a unique ``identifier'' number for each
%   list, irrespective their nesting levels.
%    \begin{macrocode}
\newcount\cclID \cclID\z@\relax
%    \end{macrocode}
% An internal global counter register \lstinline{\ccl@total@list@cnt}
% is used to count the overall number of opening lists. Currently, the
% global ID of each list is unused.
%    \begin{macrocode}
\newcount\ccl@total@list@cnt \ccl@total@list@cnt\z@\relax
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@incr@count} stores the current list ID counter in
%   a nesting-depth specific macro
%   \lstinline{ccl@prev@cnt@\the\ccl@depth}, advances the global
%   internal list counter by one, and sets the publicly available
%   counter \lstinline{\cclID} to the resulting value. Also, if the
%   nesting level is 1, the \lstinline{\cclTopID} counter is
%   incremented.
%    \begin{macrocode}
\def\ccl@incr@count{%
  \csxdef{ccl@prev@cnt@\the\ccl@depth}{\the\cclID}%
  \global\advance\ccl@total@list@cnt\@ne\relax
  \global\cclID\ccl@total@list@cnt\relax
  \ifnum\cclCurDepth=\@ne\relax
    \global\advance\cclTopID\@ne\relax
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@decr@count} resets the list counter for the next
%   lower nesting level, whenever a nested list is closed.
%    \begin{macrocode}
\def\ccl@decr@count{%
  \global\cclID\csname ccl@prev@cnt@\the\ccl@depth\endcsname\relax
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{The List Environment}
%
% List environments have the same name as their respective containers
% (preixed by the \lstinline{\ccPrefix}). However, they all call the
% low-level macros \lstinline{\cc@list} and \lstinline{\endcc@list}.
%
% \begin{macro}{\cc@list} is begin macro for the generalized coco-list
%   environment. \#1 is the attribute list of the environment.
%    \begin{macrocode}
\def\cc@list{\cc@opt@empty\@cc@list}
\def\@cc@list[#1]{%
  \ccl@advance@depth\@ne%
  \ccl@incr@count%
  \edef\ccl@cur@cont{\cc@cur@cont-\cclCurDepth}%
  \global\cclFirsttrue
%    \end{macrocode}
% If the nesting goes deeper than the style programmer anticipated:
%    \begin{macrocode}
  \ifcsdef{cc@container@\ccl@cur@cont}{}
    {\ifx\ccl@inherit\ccl@ih@common
       \let\ccl@cur@cont\cc@cur@cont%
     \else
       \global\csletcs
         {cc@type@Properties@\cc@cur@cont-\cclCurDepth}
         {cc@type@Properties@\cc@cur@cont-\cclPrevDepth}%
     \fi}%
%    \end{macrocode}
% Horizontal margin Properties from the previous nesting level are
% stored so that the nested lists can use them.
%    \begin{macrocode}
  \edef\ccl@leftskip{\the\dimexpr\leftskip\relax}%
  \edef\ccl@rightskip{\the\dimexpr\leftskip\relax}%
%    \end{macrocode}
%
% \begin{Property}{prev-margin-left}{<skip>} stores the left margin of
%   the next higher list level (i.\,e., the left margin of the list
%   item that the current list is nested into)
%    \begin{macrocode}
  \ccSetPropertyX{prev-margin-left}{\ccl@leftskip}%
%    \end{macrocode}
% \end{Property}
% \begin{Property}{prev-margin-right}{<skip>} stores the superior list
%   item's right margin.
%    \begin{macrocode}
  \ccSetPropertyX{prev-margin-right}{\ccl@rightskip}%
  \ccEvalType[\ccl@cur@cont]{Properties}%
%    \end{macrocode}
% \end{Property}
% \begin{macro}{\ccl@list@type} locally stores the current value of
%   the \UsageProp{list-type} Property.
%    \begin{macrocode}
  \edef\ccl@list@type{\ccUseProperty{list-type}}%
%    \end{macrocode}
% \end{macro}
% Processing of the optional argument.
%    \begin{macrocode}
  \cclUseAttributeHandler{#1}%
%    \end{macrocode}
% The exact values of the margins are calculated.
%    \begin{macrocode}
  \cclCalculateMarginLeft%
  \cclCalculateVMargin{top}%
  \cclCalculateVMargin{bottom}%
%    \end{macrocode}
% \begin{macro}{\Item} is a used to separate the single items of a
%   list.
%    \begin{macrocode}
  \csdef{\ccPrefix Item}{\cc@opt@empty\ccl@item}%
  \def\ccl@item[##1]{%
    \protected@edef\ccl@item@label{##1}%
    \ifx\ccl@item@label\@empty
      \cclUseLabelHandler%
    \else
      \ccComponent{Label}{##1}%
    \fi
    \sbox\z@{\@cc@is@finalfalse\ccUseProperty{label-format}}%
    \@tempdima=\dimexpr\ccUseProperty{max-label-width}\relax
    \ifdim\wd\z@<\@tempdima\relax
      \@tempdima=\the\wd\z@\relax%
    \fi
    \bgroup
      \def\cc@cur@cont{list}%
      \cc@store@latest{\the\cclTopID-number-\cclCurDepth-maxwd}{\the\@tempdima}%
      \cc@store@latest{\the\cclTopID-number-maxwd}{\the\@tempdima}%
    \egroup
    \ccSetPropertyX{label-width}{\the\@tempdima}%
    \ccUseProperty{item-format}%
    \ccUseProperty{at-begin-item-body}\ignorespaces%
  }%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\item} If default {\LaTeX} macros are replaced per
%   package option, \lstinline{\item} is made into a copy of the local
%   definition of \lstinline{\ccPrefix Item}.
%
%   \textbf{Warning:} this might be dangerous when the User tries to
%   embed something inside a {\CoCoTeX} list that uses \LaTeX's
%   standard \lstinline{\list} or \lstinline{\trivlist} environments!
%    \begin{macrocode}
  \if@ccl@replace\letcs\item{\ccPrefix Item}\fi%
%    \end{macrocode}
% \end{macro}
% Up to this point, we only managed Properties. From this point
% forward, we actually print the list. We start by using the
% \UsageProp{before-list} Property.
%    \begin{macrocode}
  \ccUseProperty{before-list}%
%    \end{macrocode}
% then, we add the top vertical skip by \UsageProp{int-margin-top}
% amount.
%    \begin{macrocode}
  \ccUseProperty{int-margin-top}%
%    \end{macrocode}
% and set the left and right margins using the
% \UsageProp{margin-left}, \UsageProp{label-sep} and
% \UsageProp{margin-right} Properties.
%    \begin{macrocode}
  \leftskip\dimexpr\ccUseProperty{margin-left}+\ccUseProperty{label-sep}\relax%
  \rightskip\dimexpr\ccUseProperty{margin-right}\relax%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endcc@list} is called at the end of each List
%   Container's respective environment. It basicly calls the
%   \UsageProp{after-list} Property one last time, decrements the
%   depth counter(s) and adds the \UsageProp{int-margin-bottom}
%   vertical skip.
%    \begin{macrocode}
\def\endcc@list{%
  \ccUseProperty{after-list}%
  \ccl@decr@count%
  \ccl@advance@depth\m@ne%
  \ccUseProperty{int-margin-bottom}%
%    \end{macrocode}
% If the List is not nested, we eventually evaluate the
% \UsageProp{after-indent} Property.
%    \begin{macrocode}
  \ifnum\cclCurDepth=\z@\relax
    \ccIfPropVal{after-indent}{false}{%
      \global\@afterindentfalse
      \aftergroup\cc@afterbox}{}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclCalculateVMargin} generates a macro that sets the
%   internal margin
%   Properties\DescribeProperty{int-margin-top}\DescribeProperty{int-margin-bottom}%
%   \UsageProperty{margin-top}\UsageProperty{margin-bottom} of the
%   (nested) list. \#1 is the orientation (\lstinline{top} or
%   \lstinline{bottom}).
%    \begin{macrocode}
\def\cclCalculateVMargin#1{%
  \ifdim\ccUseProperty{margin-#1}=\z@\relax
    \ccSetProperty{int-margin-#1}{\relax}%
  \else
    \ccSetProperty{int-margin-#1}{\addvspace{\ccUseProperty{margin-#1}}}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclCalculateLeftMargin} generates the value that
%   \lstinline{\leftskip} is set to.\UsageProperty{number-width-max}\UsageProperty{number-width-level-max}
%    \begin{macrocode}
\def\cclCalculateMarginLeft{%
  \ifcsdef{cc-list-\the\cclTopID-number-maxwd}
    {\ccSetPropertyVal{number-width-max}{\csname cc-list-\the\cclTopID-number-maxwd\endcsname}}
    {\ccSetPropertyVal{number-width-max}{1sp}}%
  \ifcsdef{cc-list-\the\cclTopID-number-\cclCurDepth-maxwd}
    {\ccSetPropertyVal{number-width-level-max}{\csname cc-list-\the\cclTopID-number-\cclCurDepth-maxwd\endcsname}}
    {\ccSetPropertyVal{number-width-level-max}{1sp}}%
  \cc@get@indent[\ccl@calc@margin@left]{}{\the\cclTopID}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@calc@margin@left} is an override for
%   coco-common's \lstinline{\cc@calc@margin@left} specific for
%   lists. Accordings to \lstinline{\cc@calc@margin@left}'s argument
%   structure, \#1 is the internal Property prefix, and \#2 is the
%   current value of the list depth counter. However, since we already
%   stored the left margin of the previous depth level in the internal
%   \UsageProp{prev-margin-left} Property, we can gobble both
%   arguments.\UsageProperty{margin-left}\UsageProperty{indent}%
%    \begin{macrocode}
\def\ccl@calc@margin@left#1#2{%
  \@tempdima=\ccUseProperty{prev-margin-left}\relax%
  \ccSetPropertyX{margin-left}{\the\dimexpr\@tempdima-\ccUseProperty{indent}\relax}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Unpacking the List Type-Specific Handlers}
%
% The caller macros for the two list type-specific Handlers for
% Attributes and Labels are defined here. They do some basic exception
% catching and then call the Handlers themselves if no error is
% detected.
%
% \begin{macro}{\cclUseLabelHandler} calls the list type specific
%   Label handler to generate a label accordingly in cases where
%   \lstinline{\item} omits the optional argument.
%    \begin{macrocode}
\def\cclUseLabelHandler{%
  \expandafter\ifx\csname ccl@make@label@\ccl@list@type\endcsname\relax
    \ccPackageError{lists}{type}
      {List type `\ccl@list@type' does not provide a Label Handler.}
      {Make sure that the body of \ccl@list@type's declaration contains a \string\DeclareLabelHandler.}
  \else
    \csname ccl@make@label@\ccl@list@type\endcsname
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclUseAttributeHandler} checks if the list type
%   specific attribute handler exists and applies it to the attribute
%   list \#1.
%    \begin{macrocode}
\def\cclUseAttributeHandler#1{%
  \ccParseAttributes{\cc@cur@cont-\cclCurDepth}{#1}%
  \expandafter\ifx\csname ccl@eval@attrs@\ccl@list@type\endcsname\relax
    \ccPackageError{Lists}{Type}
      {List type `\ccl@list@type' does not provide an Attribute Handler.}
      {Make sure that the body of \ccl@list@type's declaration contains a \string\DeclareAttributeHandler.}
  \else
    \csname ccl@eval@attrs@\ccUseProperty{list-type}\endcsname
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
% \section{Default List Types}
%
% Vanilla {\CoCoTeX} supports three list types: numbered lists
% (corresponds to \LaTeX's \lstinline{enumerate} environment),
% unnumbered lists (\lstinline{itemize}), and description lists
% (\lstinline{descripton}).
%
% \subsection{Unnumbered Lists}
%
% \DescribeContainer{unnumbered} is technically an abstract
% child Container of the \UsageContainer{List} parent.
%    \begin{macrocode}
\ccDeclareListType{unnumbered}{%
%    \end{macrocode}
% \begin{macro}{\ccl@make@label@unnumbered} generates the
%   \UsageComponent{Label} Component of an unnumbered list type.
%    \begin{macrocode}
  \DeclareLabelHandler{%
    \ccComponent{Label}{\ccUseProperty{default-label}}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@eval@attrs@itemize} is the handler for attributes
%   of itemize-like list types. Currently, it does nothing.
%    \begin{macrocode}
  \DeclareAttributeHandler{}}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Itemize-Type List  Specific Properties}
%
% \begin{Property}{default-label}{<any>} is a property that holds a
%   fallback label which is used when the optional argument of
%   \UsageMacro{\Item} is omitted.
%    \begin{macrocode}
  {\ccSetProperty{default-label}{-}}
%    \end{macrocode}
% \end{Property}
%
%
% \subsubsection{Itemize-Style Default Lists}
%
% \DescribeContainer{Itemize} is the user-level unnumbered \UsageContainer{List} Container.
%    \begin{macrocode}
\ccDeclareList{Itemize}{unnumbered}{\ccSetProperty{default-label}{\textbullet}}
\ccDeclareNested{Itemize}{1}{%
  \ccSetProperty{label-face}{\normalfont\bfseries}%
  \ccSetProperty{default-label}{ \textendash}}
\ccDeclareNested{Itemize}{2}{\ccSetProperty{default-label}{\textasteriskcentered}}
\ccDeclareNested{Itemize}{3}{\ccSetProperty{default-label}{\textperiodcentered}}
%    \end{macrocode}
%
%
% \subsection{Numbered Lists}
%
% \begin{macro}{\ccl@item@adv} is an internal counter that holds the amount by
%   which the counter of numebred lists should advance for each item.
%    \begin{macrocode}
\newcount\ccl@item@adv
%    \end{macrocode}
% \end{macro}
% \DescribeContainer{numbered} is an abstract child Container of the
% List parent that represents numbered lists.
%    \begin{macrocode}
\ccDeclareListType{numbered}{%
%    \end{macrocode}
%
% \begin{macro}{\ccl@eval@attrs@numbered} is the handler for attributes
%   specific to the enumerate-like list types.
%    \begin{macrocode}
  \DeclareAttributeHandler{%
%    \end{macrocode}
% The attribute \lstinline{step} indicates by what amount the interal
% counter should be advanced for each item. Defaults to $+1$ if none
% is given.
%    \begin{macrocode}
    \ccIfAttr{\cc@cur@cont-\cclCurDepth}{step}
      {\ccl@item@adv=\expandafter\numexpr\csname cc@\cc@cur@cont-\cclCurDepth @attr@step\endcsname\relax}%
      {\ccl@item@adv=\@ne}%
%    \end{macrocode}
% The attribute \lstinline{start} indicates the initial internal
% counter of the items in the list. The number itself is the counter
% of the first item, so we need to substract the value of
% \lstinline{step} from the given value such that \lstinline{\item} can
% advance it by that same value. If the attribute is not given, the
% internal coutner is initialized to \lstinline{0}.
%    \begin{macrocode}
    \ccIfAttr{\cc@cur@cont-\cclCurDepth}{start}
      {\ccl@item@cnt=\expandafter\numexpr\csname cc@\cc@cur@cont-\cclCurDepth @attr@start\endcsname\relax
       \advance\ccl@item@cnt-\ccl@item@adv}%
      {\ccl@item@cnt=\z@\relax}%
    }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@make@label@numbered} is the \UsageComponent{Label} handler of a
%   numbered list type.
%    \begin{macrocode}
  \DeclareLabelHandler{%
    \advance\ccl@item@cnt \ccl@item@adv\relax
    \expandafter\ifx\csname ccl@label@type@\ccUseProperty{enum-type}\endcsname\relax
      \ccPackageWarning{lists}{type}{Enum type \ccUseProperty{enum-type} is unknown, revert to numeric counters!}
      \let\ccl@label\ccl@label@type@arabic%
    \else
      \letcs\ccl@label{ccl@label@type@\ccUseProperty{enum-type}}%
    \fi
    \ccComponent{Label}{\ccl@label{\ccl@item@cnt}}
  }%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
}{%
%    \end{macrocode}
%
%
% \subsubsection{Numbered List-Specific Properties}
%
% \paragraph{New Properties}
%
% \begin{Property}{enum-type}{[arabic|roman|Roman|Alph|alph]} controls
%   how the item counter is rendered when it is not given explicitly
%   with the optional argument of \lstinline{\item}. The default
%   values are borrowed from LaTeX's default enumerate types and
%   defined below.
%    \begin{macrocode}
  \ccSetProperty{enum-type}{arabic}%
%    \end{macrocode}
% \end{Property}
%
%
% \paragraph{Properties with Deviating Default Values}
%
% By default, numeric \UsageComponent{Label} are followed by a period to accommodate
% {\LaTeX} customs.\UsageProperty{label}
%    \begin{macrocode}
  \ccSetProperty{label}{\ccUseComp{Label}.}}
%    \end{macrocode}
%
% \subsubsection{Available Counting Styles}
%
% \begin{macro}{\ccl@label@type@arabic} transforms the value of the
%   following (implicit) counter to arabic numerals.
%    \begin{macrocode}
\def\ccl@label@type@arabic{\@arabic}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@label@type@roman} transforms the value of the
%   following (implicit) counrer to lower case roman numerals.
%    \begin{macrocode}
\def\ccl@label@type@roman{\@roman}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@label@type@Roman} transforms the value of the
%   following (implicit) counrer to upper case roman numerals.
%    \begin{macrocode}
\def\ccl@label@type@Roman{\@Roman}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@label@type@alph} transforms the value of the
%   following (implicit) counrer to lower case alphabetic letters.
%    \begin{macrocode}
\def\ccl@label@type@alph{\@alph}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@label@type@Alph} transforms the value of the
%   following (implicit) counrer to upper case alphabetic letters.
%    \begin{macrocode}
\def\ccl@label@type@Alph{\@Alph}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Enumerate-Style Default Lists}
%
% \DescribeContainer{Enumerate} is the user-level Container for
% numbered \UsageContainer{List} Containers.
%    \begin{macrocode}
\ccDeclareList{Enumerate}{numbered}{}
\ccDeclareNested{Enumerate}{1}{% (
  \ccSetProperty{label}{\ccUseComp{Label})}%
  \ccSetProperty{enum-type}{alph}%
}
\ccDeclareNested{Enumerate}{2}{\ccSetProperty{enum-type}{roman}}
\ccDeclareNested{Enumerate}{3}{\ccSetProperty{enum-type}{Alph}}
%    \end{macrocode}
%
%
% \subsection{Description Lists}
%
% \DescribeContainer{text} is an abstract child Container of the List
% parent used for \lstinline{description}-like list types.
%    \begin{macrocode}
\ccDeclareListType{text}{%
%    \end{macrocode}
% \begin{macro}{\ccl@eval@attrs@text} is the handler for the
%   attributes of description-like list types.
%    \begin{macrocode}
  \DeclareAttributeHandler{%
    \ccIfAttr{\cc@cur@cont-\cclCurDepth}{width}
      {\ccSetPropertyVal{min-margin-left}{\expandafter\dimexpr\csname cc@\cc@cur@cont-\cclCurDepth @attr@width\endcsname\relax}}%
      {\ccSetProperty{min-margin-left}{2em}}%
  \ccIfPropVal{label-growth}{down}
    {\long\def\ccl@vbox##1{\smash{\vtop{##1}}}}
    {\long\def\ccl@vbox##1{\vbox{##1}}}%
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@make@label@text} creates the label of a
%   description-like list type.
%    \begin{macrocode}
  \DeclareLabelHandler{%
    \ccComponent{Label}{}%
  }}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Description-Type Specific Properties}
%
% \paragraph{New Properties}
%
% \begin{Property}{label-growth}{[up|down]} controls the direction
%   labels ``grow'' into when they need more space than
%   \UsageProp{max-label-width}. On \TeX-primitive level, it controlls
%   whether the label is put into a \lstinline{\vbox} or
%   \lstinline{\vtop} with \lstinline{\hsize=\cclItemIndent}.
%
%   \textbf{Improtant note:} If the \lstinline{label-growth} is set to
%   'down' and the description of an item uses less lines than its
%   label, the label \textit{will} flow into the next item. There is
%   no (easy) way to catch that (automatically) without destroying the
%   possibility to nesting lists.
%
%    \begin{macrocode}
 {\ccSetProperty{label-growth}{up}%
%    \end{macrocode}
% \end{Property}
% \paragraph{Properties with Deviating Default Values}
%
%
% The Properties \UsageProp{margin-left} and \UsageProp{indent} of
% text-type lists are by default set to \lstinline{auto}.
%    \begin{macrocode}
  \ccSetProperty{indent}{auto}%
  \ccSetProperty{margin-left}{auto}%
%    \end{macrocode}
% To accommodate for the new \UsageProp{label-grow} option, the
% \UsageProp{label-box} has a conditional that switches between
% regular \lstinline{\hbox} labels and the two \lstinline{\vbox}
% variants described above.
%    \begin{macrocode}
  \ccSetProperty{label-box}{%
    \ifdim\ccUseProperty{label-width}<\ccUseProperty{max-label-width}\relax
      \hbox to \cclItemIndent{%
        \ccIfPropVal{label-align}{left}{}{\hss}%
        \ccUseProperty{label-format}%
        \ccIfPropVal{label-align}{right}{}{\hss}}%
    \else
      \ccl@vbox{\relax%
        \hsize\dimexpr\cclItemIndent%
        \leftskip\z@
        \rightskip\z@
        \parindent\z@
        \leavevmode
        \ccUseProperty{label-format}%
        \@@par
      }%
    \fi
  }}
%    \end{macrocode}
%
%
% \subsubsection{Description-Type Default Lists}
%
% \DescribeContainer{Description} is the user-level Container for text
% type \UsageContainer{List} Containers.
%
% As with the standard \LaTeX \lstinline{description}
% environment, there are no default definitions for nested
% Description-type lists.\UsageProperty{label-face}
%    \begin{macrocode}
\ccDeclareList{Description}{text}{%
  \ccSetProperty{label-face}{\bfseries}
}
%    \end{macrocode}
%
%
% \subsection{Replacing \LaTeX's Default Lists}
%
% At the User's descretion (using the \lstinline{replace} package
% option, see Sect.~\ref{sec:coco-lists:options}, above), \LaTeX's
% default list environments \lstinline{itemize},
% \lstinline{enumerate}, and \lstinline{description} are re-defined to
% use \CoCoTeX's list mechanism, instead.
%    \begin{macrocode}
\if@ccl@replace
  \letcs\itemize{\ccPrefix Itemize}
  \letcs\enditemize{end\ccPrefix Itemize}
  \letcs\enumerate{\ccPrefix Enumerate}
  \letcs\endenumerate{end\ccPrefix Enumerate}
  \letcs\description{\ccPrefix Description}
  \letcs\enddescription{end\ccPrefix Description}
\fi
%    \end{macrocode}
%    \begin{macrocode}[numbers=none,gobble=1]
%</lists>
%    \end{macrocode}
