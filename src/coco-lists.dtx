% \chapter{coco-lists.dtx}
% This module provides handlers for list-like environments like item
% lists, enumerations, glossaries and descriptions.
%    \begin{macrocode}[gobble=1]
%<*lists>
%    \end{macrocode}
%
% \textbf{Note:} The \lstinline{coco-lists} module diverges somewhat
% from the other {\CoCoTeX} modules insofar as that its main Container
% does not follow the \CoCoTeX's usual ``collect all--process later''
% approach, but all Properties are processed at the beginning of each
% Container's instances and the contents are processed as they are
% parsed by the \lstinline{\LaTeX} interpreter, just like ``reguar''
% {\LaTeX} lists. Configuration of lists, however, follows the
% {\CoCoTeX} playbook.
%
% \section{Preamble}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2018/12/01]
\ProvidesPackage{coco-lists}
    [\filedate \fileversion CoCoTeX lists module]
\RequirePackage{coco-common}
%    \end{macrocode}
%
%
% \subsection{Package Options}\label{sec:coco-lists:options}
%
% If the \lstinline{replace} option is set, LaTeX's default lists are
% replaced by \lstinline{coco-lists} module. This effects \LaTeX's
% \lstinline{enumerate}, \lstinline{itemize}, and
% \lstinline{description} environments.
%    \begin{macrocode}
\newif\if@ccl@replace \@ccl@replacefalse
\DeclareOptionX{replace}{\global\@ccl@replacetrue}%
%    \end{macrocode}
% The option inherit defines how nested lists inherit their
% properties. Currently, there are two ways: \lstinline{common}: All
% nested lists of the same type inherit only from the same, generic
% type definition; \lstinline{conseq}: nested lists of the same type
% inherit from the next-higher level list of the same type, and from
% the generic type definition.
%
% For example, if \lstinline{inherit=common}, 3rd level
% \lstinline{itemize} and 2nd level \lstinline{itemize} both inherit
% only the property values of the same generic \lstinline{itemize}
% list type. If \lstinline{inherit=conseq}, 3rd level inherits the
% property lists from 2nd level \lstinline{itemize}.
%
% Since inheritance is a transitive relation, 3rd level
% \lstinline{itemize} will ultimately also inherit the Properties from
% generic \lstinline{itemize}, but in contrast to \lstinline{common},
% \lstinline{conseq} allows 2nd level \lstinline{itemize} to override
% some Properties of generic \lstinline{itemize}, which will be
% propagate down to 3rd level \lstinline{itemize}, while with
% \lstinline{inherit=common}, the override on 2nd level
% \lstinline{itemize} would have no effect on 3rd level
% \lstinline{itemize}.
%    \begin{macrocode}
\def\ccl@ih@common{common}
\def\ccl@ih@conseq{conseq}%
\let\ccl@inherit\ccl@ih@common
\define@choicekey{coco-lists.sty}{inherit}[\@ccl@inherit\nr]{conseq,common}{%
  \ifcase\nr\relax% conseq: nested lists of the same type inherit only from the previous level
    \global\let\ccl@inherit\ccl@ih@conseq
  \fi
}
%    \end{macrocode}
% The nesting option sets whether the nesting level of a list should
% be counted list-specific (value \lstinline{local}), or
% globally (value \lstinline{global}, default).
%    \begin{macrocode}
\def\ccl@str@local{local}%
\def\ccl@str@global{global}%
\let\ccl@nesting\ccl@str@global
\define@choicekey{coco-lists.sty}{nesting}[\@ccl@nesting\nr]{local,global}{%
  \ifcase\nr\relax% local
    \global\let\ccl@nesting\ccl@str@local
  \fi
}
\ProcessOptionsX
%    \end{macrocode}
%
% \section{The List Container}
%
% The \lstinline{List} Container is the most abstract Container for lists. 
%
%    \begin{macrocode}
\ccDeclareContainer{List}{%
  \ccDeclareType{Properties}{%
    %% list formatting
    \ccSetProperty{before-list}{% at the very beginning of each (nested) list
      \if@noskipsec \leavevmode \fi
      \ifvmode\else
        \unskip \par
      \fi
      \ccaStructStart{L}% Start Tag for the (nested) list
    }%
    \ccSetProperty{after-list}{% after each (nested) list
      \ccUseProperty{after-item}%
      \ccaStructEnd{L}% end tag for the (nested) list
    }%
    %% list margins
    \ccSetProperty{margin-top}{\z@}% vertical space after the list.
    \ccSetProperty{margin-bottom}{\z@}% vertical space before the list.
    \ccSetProperty{margin-left}{\csname leftmargin\@roman\cclCurDepth\endcsname-\ccUseProperty{label-sep}+\ccUseProperty{prev-margin-left}}% horizontal space to the left of each item, from left boundary of the page area (auto=width of widest label + prev-margin-left, top-level-list-wise)
    \ccSetProperty{max-label-width}{.33\textwidth}% maximum margin reserved for list labels
    \ccSetProperty{margin-right}{\z@}% horizontal space to the right of each list item
    %% between list items
    \ccSetProperty{item-sep}{\z@}% vertical space between two adjacent list items (real: this value + par-skip)
    \ccSetProperty{after-indent}{false}% whether the paragraph after the list should have an indent (true) or not (false)
    \ccSetProperty{at-begin-item-body}{\ccaVstructStart{LBody}}% right at the beginning of a new item body
    \ccSetProperty{at-end-item-body}{\ccaVstructEnd{LBody}}% at the very end of an item body, but before \par
    \ccSetProperty{after-item}{% material after each item
      \ccUseProperty{at-end-item-body}%
      \ccaVstructEnd{LI}% Close list item tags
      \par}%
    \ccSetProperty{before-item}{%
      \ifcclFirst
        \global\cclFirstfalse
      \else
        \ccUseProperty{after-item}%
        \vskip\ccUseProperty{item-sep}%
      \fi
      \parindent\ccUseProperty{par-indent}\relax%
      \parskip\ccUseProperty{par-skip}\relax%
      \parfillskip\ccUseProperty{par-fill-skip}\relax%
      \noindent
      \leavevmode
      \ccaVstructStart{LI}% Start tag for a list item
    }%
    \ccSetProperty{item-offset}{% Setting the label indent and first-line offset
      \cclItemIndent\ccUseProperty{indent}%
      \advance\cclItemIndent\dimexpr-\ccUseProperty{label-sep}\relax
      \hskip\cclItemIndent\relax%
      \ifdim\ccUseProperty{indent}>\z@
        \cclItemIndent\ccUseProperty{indent}%
      \else
        \cclItemIndent-\ccUseProperty{indent}%
      \fi
    }%
    %% inside list items
    \ccSetProperty{par-indent}{\parindent}% indent of the first line of a *new* paragraph inside a list item
    \ccSetProperty{par-fill-skip}{\@flushglue}% skip at the end of the last line of each paragraph inside a list item
    \ccSetProperty{par-skip}{\z@}% vertical space between two adjacent paragraphs inside a list item
    %% label formatting
    \ccSetProperty{label}{\ccUseComp{Label}}% The Label Component is set via the optional argument of \Item, otherwise it is generated
    \ccSetProperty{indent}{-\dimexpr\csname leftmargin\@roman\cclCurDepth\endcsname-\ccUseProperty{label-sep}\relax}% indent of each list item's first line (relative to margin-left) NOTE: auto-global is valid, but it causes *all* lists -- despite the nesting level -- to have the same left margin and indent!
    \ccSetProperty{label-sep}{.5em}% horizontal skip between each item's label and its content
    \ccSetProperty{label-face}{}% font of the item's label
    \ccSetProperty{label-align}{left}% alignment of label within its \hbox
    \ccSetProperty{label-format}{% format of the label itself
      \ccUseProperty{label-face}%
      \ccaVstructStart{Lbl}% Start Tag for the item's label
      \ccUseProperty{label}%
      \ccaVstructEnd{Lbl}% End tag for the item's label
    }%
    \ccSetProperty{label-box}{% hbox that contains and aligns the label
      \hbox to \cclItemIndent{%
        \ccIfPropVal{label-align}{left}{}{\hss}%
        \ccUseProperty{label-format}%
        \ccIfPropVal{label-align}{right}{}{\hss}}%
    }%
    \ccSetProperty{item-format}{% material at the beginning of a new item
      \ccUseProperty{before-item}%
      \ccUseProperty{item-offset}%
      \ccUseProperty{label-box}%
      \hskip\ccUseProperty{label-sep}%
    }%
  }%
  \ccDeclareType{Components}{%
    \ccDeclareComponent{Label}%
  }%
  \ccDeclareEnv{cc@list}{endcc@list}%
}
%    \end{macrocode}
%
%
% \section{Declaring List Types}
%
% List Types are the next layer of abstraction for lists. This layer
% distinguishes numbered from unnnumbered and description lists.
%
% \begin{macro}{\DeclareListType} declares a new list type. \#1 is the
%   name of the list type, \#2 is the declaration body. Each new list
%   type should declare at least an Attribute handler and a Label
%   handler. \#3 is a list of type specific properties that are
%   appended to the generic list's property list.
%    \begin{macrocode}
\long\def\ccDeclareListType#1#2#3{%
%    \end{macrocode}
% \begin{macro}{\DeclareAttributeHandler} declares a new handler
%   for a list's attributes. \#\#1 is the definition body.
%    \begin{macrocode}
  \def\DeclareAttributeHandler##1{\csdef{ccl@eval@attrs@#1}{##1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\DeclareLabelHandler} declares a new handler for each
%   item's label.  \#\#1 is the definition body. It should fill the Label Component with content in case the optional  argument of item is omitted.
%    \begin{macrocode}
  \def\DeclareLabelHandler##1{\csdef{ccl@make@label@#1}{##1}}%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
  \ccDeclareContainer{#1List}{%
    \ccInherit{Components,Properties}{List}%
    \ccDeclareType{Properties}{%
      \ccSetProperty{list-type}{#1}%
      #3%
    }%
    \ccDeclareEnv[#1-list]{cc@list}{endcc@list}%
  }%
  #2%
}
%    \end{macrocode}
% \end{macro}
%
%
% \section{Declare Lists}
%
% The next layer of abstraction is the user-level List container. Each
% list container must be assigned to a list type from which it will
% inherit its type-specific properties.
%
% \begin{macro}{\ccDeclareList} defines a new list. \#1 is the name of
%   the list environment (sans \lstinline{\ccPrefix}), \#2 is the list
%   type, \#3 is the list-specific Property list.
%    \begin{macrocode}
\def\ccDeclareList#1#2#3{%
  \csxdef{cc@cur@depth@#1}{\z@}%
  \ccDeclareContainer{#1}{%
    \ccInherit{Properties,Components}{#2List}%
    \ccDeclareType{Properties}{#3}%
    \ccDeclareEnv[#1]{\cc@list}{\endcc@list}%
  }%
  \ccDeclareNested{#1}{\z@}{#3}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccDeclareNested} can be used to declare Property
%   overrides for nested lists. \#1 is the list name, \#2 is the
%   nesting depth ($\#2$th nesting level means that the Properties are
%   used for the $n+1$-th list of the same name), \#3 is the Property
%   list.
%    \begin{macrocode}
\def\ccDeclareNested#1#2#3{%
  \@tempcnta=#2\relax
  \ifx\@tempcnta<\@ne\relax
    \ccPackageError{lists}{Nesting}{Invalid nesting level!}{You cannot declare nesting levels less than 1!}%
  \fi
  \advance\@tempcnta\@ne\relax
  \ccDeclareContainer{#1-\the\@tempcnta}{%
    \ifcsdef{cc@container@#1}
      {\ccInherit{Properties,Components}{#1}}
      {\ccPackageError{lists}{Inheritance}
        {List `#1' undefined!}
        {You need to define the list `#1' before you can declare nested list overrides!}}%
      \ccDeclareType{Properties}{#3}%
    }%
}
%    \end{macrocode}
% \end{macro}
%
% We want to count each list type seperately to ensure the correct
% item label is printed, but we also need to keep within the global
% nesting level limit. Therefore, we set two internal counters, one
% for the overall nesting level, and another one for each list
% type. Note that the latter is a macro, not a counter register.
%
% \begin{macro}{\ccl@depth} is the counter for the overall nesting level.
%    \begin{macrocode}
\newcount\ccl@depth
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@item@cnt} is the internal counter for the items within a (nested) list level.
%    \begin{macrocode}
\newcount\ccl@item@cnt
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ifcclFirst} is true as long as the first item of a
%     list is processed.
%    \begin{macrocode}
\newif\ifcclFirst \cclFirsttrue
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@advance@depth} is a helper macro to advance both
%   the global list nesting level, as well as the list Container
%   specific nesting level. \#1 is the amount by which both counters
%   should be advanced.
%    \begin{macrocode}
\def\ccl@advance@depth#1{\csname ccl@advance@depth@\ccl@nesting\endcsname{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@advance@depth@global} is called when the nesting
%   level should be counted for all lists equally without respecting
%   the list type.
%    \begin{macrocode}
\def\ccl@advance@depth@global#1{%
  \edef\cclPrevDepth{\the\ccl@depth}%
  \global\advance\ccl@depth#1\relax
  \edef\cclCurDepth{\the\ccl@depth}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@advance@depth@local} is called when the nesting
%   level should be counted for each list type individually.
%    \begin{macrocode}
\def\ccl@advance@depth@local#1{%
  \letcs\cclPrevDepth{cc@cur@depth@\cc@cur@cont}%
  \expandafter\@tempcnta\csname cc@cur@depth@\cc@cur@cont\endcsname\relax
  \advance\@tempcnta#1\relax
  \csxdef{cc@cur@depth@\cc@cur@cont}{\the\@tempcnta}%
  \edef\cclCurDepth{\csname cc@cur@depth@\cc@cur@cont\endcsname}%
  \global\advance\ccl@depth#1\relax
}
\newskip\cclItemIndent
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cclTopID} is a counter that stores a unique number
%   for each top-level List Instance. It is used to calculate the
%   margins of both top-level items and items of nested lists.
%    \begin{macrocode}
\newcount\cclTopID       \cclTopID\z@\relax
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclID} stores a unique ``identifier'' number for each
%   list, irrespective their nesting levels. An internal global
%   counter register \lstinline{\ccl@total@list@cnt} is used to count
%   the overall number of opening lists. Currently, the global ID of
%   each list is unused.
%    \begin{macrocode}
\newcount\cclID \cclID\z@\relax
\newcount\ccl@total@list@cnt \ccl@total@list@cnt\z@\relax
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@incr@count} stores the current list ID counter in
%   a nesting-depth specific macro
%   \lstinline{ccl@prev@cnt@\the\ccl@depth}, advances the global
%   internal list counter by one, and sets the publicly available
%   counter \lstinline{\cclID} to the resulting value. Also, if the
%   nesting level is 1, the \lstinline{\cclTopID} counter is
%   incremented.
%    \begin{macrocode}
\def\ccl@incr@count{%
  \csxdef{ccl@prev@cnt@\the\ccl@depth}{\the\cclID}%
  \global\advance\ccl@total@list@cnt\@ne\relax
  \global\cclID\ccl@total@list@cnt\relax
  \ifnum\cclCurDepth=\@ne\relax
    \global\advance\cclTopID\@ne\relax
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@decr@count} resets the list counter for the next
%   lower nesting level, whenever a nested list is closed.
%    \begin{macrocode}
\def\ccl@decr@count{%
  \global\cclID\csname ccl@prev@cnt@\the\ccl@depth\endcsname\relax
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{The List Environment}
%
% List environments have the same name as their respective containers
% (preixed by the \lstinline{\ccPrefix}). However, they all call the
% low-level macros \lstinline{\cc@list} and \lstinline{\endcc@list}.
%
% \begin{macro}{\cc@list} is begin macro for the generalized coco-list
%   environment. \#1 is the attribute list of the environment.
%    \begin{macrocode}
\def\cc@list{\cc@opt@empty\@cc@list}
\def\@cc@list[#1]{%
  \ccl@advance@depth\@ne%
  \ccl@incr@count%
  \edef\ccl@cur@cont{\cc@cur@cont-\cclCurDepth}%
  \global\cclFirsttrue
%    \end{macrocode}
% If the nesting goes deeper than the style programmer anticipated:
%    \begin{macrocode}
  \ifcsdef{cc@container@\ccl@cur@cont}{}
    {\ifx\ccl@inherit\ccl@ih@common
       \let\ccl@cur@cont\cc@cur@cont%
     \else
       \global\csletcs
         {cc@type@Properties@\cc@cur@cont-\cclCurDepth}
         {cc@type@Properties@\cc@cur@cont-\cclPrevDepth}%
     \fi}%
%    \end{macrocode}
% Horizontal margin Properties from the previous nesting level are
% stored so that the nested lists can use them:
%    \begin{macrocode}
  \ccSetPropertyX{prev-margin-left}{\the\leftskip}%
  \ccSetPropertyX{prev-margin-right}{\the\rightskip}%
  \ccEvalType[\ccl@cur@cont]{Properties}%
  \edef\ccl@list@type{\ccUseProperty{list-type}}%
%    \end{macrocode}
% Processing of the optional argument.
%    \begin{macrocode}
  \cclUseAttributeHandler{#1}%
%    \end{macrocode}
% The macro that separates the items of the list is defined locally so
% that we can use Properties:
%    \begin{macrocode}
  \cclCalculateMarginLeft%
  \cclCalculateVMargin{top}%
  \cclCalculateVMargin{bottom}%
  \csdef{\ccPrefix Item}{\cc@opt@empty\ccl@item}%
  \def\ccl@item[##1]{%
    \edef\ccl@item@label{##1}%
    \ifx\ccl@item@label\@empty
      \cclUseLabelHandler%
    \else
      \ccComponent{Label}{##1}%
    \fi
    \sbox\z@{\@cc@is@finalfalse\ccUseProperty{label-format}}%
    \@tempdima=\dimexpr\ccUseProperty{max-label-width}\relax
    \ifdim\wd\z@<\@tempdima\relax
      \@tempdima=\the\wd\z@\relax%
    \fi
    \bgroup
      \def\cc@cur@cont{list}%
      \cc@store@latest{\the\cclTopID-number-\cclCurDepth-maxwd}{\the\@tempdima}%
      \cc@store@latest{\the\cclTopID-number-maxwd}{\the\@tempdima}%
    \egroup
    \ccSetPropertyX{label-width}{\the\@tempdima}%
    \ccUseProperty{item-format}%
    \ccUseProperty{at-begin-item-body}\ignorespaces%
  }%
%    \end{macrocode}
% If default {\LaTeX} macros are replaced per package option,
% \lstinline{\item} is made into a copy of the local definition of
% \lstinline{\ccPrefix Item}.
%    \begin{macrocode}
  \if@ccl@replace\letcs\item{\ccPrefix Item}\fi%
%    \end{macrocode}
% Up to this point, we only managed Properties. From this point
% forward, we actually print the list:
%    \begin{macrocode}
  \ccUseProperty{before-list}%
  \ccUseProperty{int-margin-top}%
  \leftskip\dimexpr\ccUseProperty{margin-left}+\ccUseProperty{label-sep}\relax%
  \rightskip\dimexpr\ccUseProperty{margin-right}\relax%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\endcc@list} is expanded at the end of each List
%   Container's respective environment. It basicly calls the
%   after-list Property one last time and decrements the depth
%   counter(s).
%    \begin{macrocode}
\def\endcc@list{%
  \ccUseProperty{after-list}%
  \ccl@decr@count%
  \ccl@advance@depth\m@ne%
  \ccUseProperty{int-margin-bottom}%
  \ifnum\cclCurDepth=\z@\relax
    \ccIfPropVal{after-indent}{false}{%
      \global\@afterindentfalse
      \global\everypar{%
        \if@afterindent \else
          {\setbox\z@\lastbox}%
        \fi
        \global\everypar{}}}{}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclCalculateVMargin} generates a macro that realizes
%   the internal vertical margin of the (nested) list. \#1 is the
%   orientation (\lstinline{top} or \lstinline{bottom}).
%    \begin{macrocode}
\def\cclCalculateVMargin#1{%
  \ifdim\ccUseProperty{margin-#1}=\z@\relax
    \ccSetProperty{int-margin-#1}{\relax}%
  \else
    \ccSetProperty{int-margin-#1}{\addvspace{\ccUseProperty{margin-#1}}}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclCalculateLeftMargin} generates the value that
%   \lstinline{\leftskip} is set to.
%    \begin{macrocode}
\def\cclCalculateMarginLeft{%
  \ifcsdef{cc-list-\the\cclTopID-number-maxwd}
    {\ccSetPropertyVal{number-width-max}{\csname cc-list-\the\cclTopID-number-maxwd\endcsname}}
    {\ccSetPropertyVal{number-width-max}{1sp}}%
  \ifcsdef{cc-list-\the\cclTopID-number-\cclCurDepth-maxwd}
    {\ccSetPropertyVal{number-width-level-max}{\csname cc-list-\the\cclTopID-number-\cclCurDepth-maxwd\endcsname}}
    {\ccSetPropertyVal{number-width-level-max}{1sp}}%
  \cc@get@indent[\ccl@calc@margin@left]{}{\the\cclTopID}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@calc@margin@left} is an override for
%   coco-common's \lstinline{\cc@calc@margin@left} specific for
%   lists. Accordings to \lstinline{\cc@calc@margin@left}'s argument
%   structure, \#1 is the internal Property prefix, and \#2 is the
%   current value of the list depth counter. However, since we already
%   stored the left margin of the previous depth level in the internal
%   \lstinline{prev-margin-left} Property, we can gobble both
%   arguments.
%    \begin{macrocode}
\def\ccl@calc@margin@left#1#2{%
  \@tempdima=\ccUseProperty{prev-margin-left}\relax%
  \ccSetPropertyX{margin-left}{\the\dimexpr\@tempdima-\ccUseProperty{indent}\relax}%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Unpacking the List Type-Specific Handlers}
%
% The caller macros for the two list type-specific Handlers for
% Attributes and Labels are defined here. They do some basic exception
% catching and then call the Handlers themselves if no error is
% detected.
%
% \begin{macro}{\cclUseLabelHandler} calls the list type specific
%   Label handler to generate a label accordingly in cases where
%   \lstinline{\item} omits the optional argument.
%    \begin{macrocode}
\def\cclUseLabelHandler{%
  \expandafter\ifx\csname ccl@make@label@\ccl@list@type\endcsname\relax
    \ccPackageError{lists}{type}
      {List type `\ccl@list@type' does not provide a Label Handler.}
      {Make sure that the body of \ccl@list@type's declaration contains a \string\DeclareLabelHandler.}
  \else
    \csname ccl@make@label@\ccl@list@type\endcsname
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cclUseAttributeHandler} checks if the list type
%   specific attribute handler exists and applies it to the attribute
%   list \#1.
%    \begin{macrocode}
\def\cclUseAttributeHandler#1{%
  \ccParseAttributes{\cc@cur@cont-\cclCurDepth}{#1}%
  \expandafter\ifx\csname ccl@eval@attrs@\ccl@list@type\endcsname\relax
    \ccPackageError{Lists}{Type}
      {List type `\ccl@list@type' does not provide an Attribute Handler.}
      {Make sure that the body of \ccl@list@type's declaration contains a \string\DeclareAttributeHandler.}
  \else
    \csname ccl@eval@attrs@\ccUseProperty{list-type}\endcsname
  \fi
}
%    \end{macrocode}
% \end{macro}
%
%
% \section{Default List Types}
%
% Vanilla {\CoCoTeX} supports three list types: numbered lists
% (corresponds to \LaTeX's \lstinline{enumerate} environment),
% unnumbered lists (\lstinline{itemize}), and description lists
% (\lstinline{descripton}).
%
% \subsection{Unnumbered Lists}
%
%    \begin{macrocode}
\ccDeclareListType{unnumbered}{%
%    \end{macrocode}
% \begin{macro}{\ccl@make@label@unnumbered} creates the label of an
%   unnumbered list type.
%    \begin{macrocode}
  \DeclareLabelHandler{%
    \ccComponent{Label}{\ccUseProperty{default-label}}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@eval@attrs@itemize} is the handler for attributes
%   of itemize-like list types. Currently, it does nothing.
%    \begin{macrocode}
  \DeclareAttributeHandler{}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Itemize-Type List  Specific Properties}
%
% For unnumbered lists there is one new Property,
% \lstinline{default-label} which defines a fallback label.
%    \begin{macrocode}
}{\ccSetProperty{default-label}{-}}
%    \end{macrocode}
%
%
% \subsubsection{Itemize-Style Default Lists}
%
%    \begin{macrocode}
\ccDeclareList{Itemize}{unnumbered}{\ccSetProperty{default-label}{\textbullet}}
\ccDeclareNested{Itemize}{1}{%
  \ccSetProperty{label-face}{\normalfont\bfseries}%
  \ccSetProperty{default-label}{ \textendash}}
\ccDeclareNested{Itemize}{2}{\ccSetProperty{default-label}{\textasteriskcentered}}
\ccDeclareNested{Itemize}{3}{\ccSetProperty{default-label}{\textperiodcentered}}
%    \end{macrocode}
%
%
% \subsection{Numbered Lists}
%
% \begin{macro}{\ccl@item@adv} is an internal counter that holds the amount by
%   which the counter of numebred lists should advance for each item.
%    \begin{macrocode}
\newcount\ccl@item@adv
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
\ccDeclareListType{numbered}{%
%    \end{macrocode}
%
% \begin{macro}{\ccl@eval@attrs@numbered} is the handler for attributes
%   specific to the enumerate-like list types.
%    \begin{macrocode}
  \DeclareAttributeHandler{%
%    \end{macrocode}
% The attribute \lstinline{step} indicates by what amount the interal
% counter should be advanced for each item. Defaults to $+1$ if none
% is given.
%    \begin{macrocode}
    \ccIfAttr{\cc@cur@cont-\cclCurDepth}{step}
      {\ccl@item@adv=\expandafter\numexpr\csname cc@\cc@cur@cont-\cclCurDepth @attr@step\endcsname\relax}%
      {\ccl@item@adv=\@ne}%
%    \end{macrocode}
% The attribute \lstinline{start} indicates the initial internal
% counter of the items in the list. The number itself is the counter
% of the first item, so we need to substract the value of
% \lstinline{step} from the given value such that \lstinline{\item} can
% advance it by that same value. If the attribute is not given, the
% internal coutner is initialized to \lstinline{0}.
%    \begin{macrocode}
    \ccIfAttr{\cc@cur@cont-\cclCurDepth}{start}
      {\ccl@item@cnt=\expandafter\numexpr\csname cc@\cc@cur@cont-\cclCurDepth @attr@start\endcsname\relax
       \advance\ccl@item@cnt-\ccl@item@adv}%
      {\ccl@item@cnt=\z@\relax}%
    }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@make@label@numbered} is the label handler of a
%   numbered list type.
%    \begin{macrocode}
  \DeclareLabelHandler{%
    \advance\ccl@item@cnt \ccl@item@adv\relax
    \expandafter\ifx\csname ccl@label@type@\ccUseProperty{enum-type}\endcsname\relax
      \ccPackageWarning{lists}{type}{Enum type \ccUseProperty{enum-type} is unknown, revert to numeric counters!}
      \let\ccl@label\ccl@label@type@arabic%
    \else
      \letcs\ccl@label{ccl@label@type@\ccUseProperty{enum-type}}%
    \fi
    \ccComponent{Label}{\ccl@label{\ccl@item@cnt}}
  }%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
}{%
%    \end{macrocode}
%
%
% \subsubsection{Numbered List-Specific Properties}
%
% \paragraph{New Properties}
%
% The new Property \lstinline{enum-type} controls how the item counter
% is rendered when it is not given explicitly with the optional
% argument of \lstinline{\item}. The default values are borrowed from
% LaTeX's default enumerate types and defined below.
%    \begin{macrocode}
  \ccSetProperty{enum-type}{arabic}%
%    \end{macrocode}
% 
%
% \paragraph{Properties with Deviating Default Values}
%
% By default, numeric labels are followed by a period to accommodate
% {\LaTeX} customs.
%    \begin{macrocode}
  \ccSetProperty{label}{\ccUseComp{Label}.}}
%    \end{macrocode}
%
% \subsubsection{Available Counting Styles}
%
% \begin{macro}{\ccl@label@type@arabic} transforms the value of the
%   following (implicit) counter to arabic numerals.
%    \begin{macrocode}
\def\ccl@label@type@arabic{\@arabic}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@label@type@roman} transforms the value of the
%   following (implicit) counrer to lower case roman numerals.
%    \begin{macrocode}
\def\ccl@label@type@roman{\@roman}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@label@type@Roman} transforms the value of the
%   following (implicit) counrer to upper case roman numerals.
%    \begin{macrocode}
\def\ccl@label@type@Roman{\@Roman}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@label@type@alph} transforms the value of the
%   following (implicit) counrer to lower case alphabetic letters.
%    \begin{macrocode}
\def\ccl@label@type@alph{\@alph}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@label@type@Alph} transforms the value of the
%   following (implicit) counrer to upper case alphabetic letters.
%    \begin{macrocode}
\def\ccl@label@type@Alph{\@Alph}
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Enumerate-Style Default Lists}
%
%    \begin{macrocode}
\ccDeclareList{Enumerate}{numbered}{}
\ccDeclareNested{Enumerate}{1}{% (
  \ccSetProperty{label}{\ccUseComp{Label})}%
  \ccSetProperty{enum-type}{alph}%
}
\ccDeclareNested{Enumerate}{2}{\ccSetProperty{enum-type}{roman}}
\ccDeclareNested{Enumerate}{3}{\ccSetProperty{enum-type}{Alph}}
%    \end{macrocode}
%
%
% \subsection{Description Lists}
%
%    \begin{macrocode}
\ccDeclareListType{text}{%
%    \end{macrocode}
% \begin{macro}{\ccl@eval@attrs@text} is the handler for the
%   attributes of description-like list types.
%    \begin{macrocode}
  \DeclareAttributeHandler{%
    \ccIfAttr{\cc@cur@cont-\cclCurDepth}{width}
      {\ccSetPropertyVal{min-margin-left}{\expandafter\dimexpr\csname cc@\cc@cur@cont-\cclCurDepth @attr@width\endcsname\relax}}%
      {\ccSetProperty{min-margin-left}{2em}}%
  \ccIfPropVal{label-growth}{down}
    {\long\def\ccl@vbox##1{\smash{\vtop{##1}}}}
    {\long\def\ccl@vbox##1{\vbox{##1}}}%
  }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccl@make@label@text} creates the label of a
%   description-like list type.
%    \begin{macrocode}
  \DeclareLabelHandler{%
    \ccComponent{Label}{}%
  }
%    \end{macrocode}
% \end{macro}
%
%
% \subsubsection{Description-Type Specific Properties}
%
% \paragraph{New Properties}
%
% There is a new Property, \lstinline{label-growth}, which can be set
% to \lstinline{up} or \lstinline{down} and which controls the
% direction labels ``grow'' into when they need more space than
% \lstinline{max-label-width}. On \TeX-primitive level, it controlls
% whether the label is put into a \lstinline{\vbox} or
% \lstinline{\vtop} with \lstinline{\hsize=\cclItemIndent}.
%
% \textbf{Improtant note:} If the \lstinline{label-growth} is set to
% 'down' and the description of an item uses less lines than its
% label, the label \textit{will} flow into the next item. There is no
% (easy) way to catch that (automatically) without destroying the
% possibility to nesting lists.
%
% \paragraph{Properties with Deviating Default Values}
%
% To accommodate for the new option, the \lstinline{label-box} has a
% conditional that switches between regular \lstinline{\hbox} labels
% and the two \lstinline{\vbox} variants described above..
%
% The Properties \lstinline{margin-left} and \lstinline{indent} of
% text-type lists are by default set to \lstinline{auto}.
%    \begin{macrocode}
}{%
  \ccSetProperty{label-growth}{up}% or 'down'; where a multi-line label should "grow" to.
  \ccSetProperty{indent}{auto}%
  \ccSetProperty{margin-left}{auto}%
  \ccSetProperty{label-box}{%
    \ifdim\ccUseProperty{label-width}<\ccUseProperty{max-label-width}\relax
      \hbox to \cclItemIndent{%
        \ccIfPropVal{label-align}{left}{}{\hss}%
        \ccUseProperty{label-format}%
        \ccIfPropVal{label-align}{right}{}{\hss}}%
    \else
      \ccl@vbox{\relax%
        \hsize\dimexpr\cclItemIndent%
        \leftskip\z@
        \rightskip\z@
        \parindent\z@
        \leavevmode
        \ccUseProperty{label-format}%
        \@@par
      }%
    \fi
  }%
}
%    \end{macrocode}
%
%
% \subsubsection{Description-Type Default Lists}
%
% As with the standard \LaTeX \lstinline{description}
% environment, there are no default definitions for nested
% Description-type lists.
%    \begin{macrocode}
\ccDeclareList{Description}{text}{%
  \ccSetProperty{label-face}{\bfseries}
}
%    \end{macrocode}
%
%
% \subsection{Replacing \LaTeX's Default Lists}
%
% At the User's descretion (using the \lstinline{replace} package
% option, see Sect.~\ref{sec:coco-lists:options}, above), \LaTeX's
% default list environments \lstinline{itemize},
% \lstinline{enumerate}, and \lstinline{description} are re-defined to
% use \CoCoTeX's list mechanism, instead.
%    \begin{macrocode}
\if@ccl@replace
  \letcs\itemize{\ccPrefix Itemize}
  \letcs\enditemize{end\ccPrefix Itemize}
  \letcs\enumerate{\ccPrefix Enumerate}
  \letcs\endenumerate{end\ccPrefix Enumerate}
  \letcs\description{\ccPrefix Description}
  \letcs\enddescription{end\ccPrefix Description}
\fi
%    \end{macrocode}
%    \begin{macrocode}[gobble=1]
%</lists>
%    \end{macrocode}
