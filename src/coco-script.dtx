% \chapter{coco-script.dtx}
%    \begin{macrocode}[numbers=none,gobble=1]
%<*script>
%    \end{macrocode}
%
% This package is used to handle non-latin based script systems like
% Japanese, Chinese, Armenian and the like.
%    \begin{macrocode}
%% module for CoCoTeX that handles script switching.
%%
%% Maintainer: p.schulz@le-tex.de
%%
%% lualatex  -  texlive > 2019
%%
\NeedsTeXFormat{LaTeX2e}[2020/06/01]
\ProvidesPackage{coco-script}
    [\filedate \fileversion CoCoTeX script module]
%    \end{macrocode}
% The argument of the \lstinline{usescript} option is a list of script
% systems that are used in the document. It is used to determine the
% additional fonts that are to be loaded via the babel package.
%    \begin{macrocode}
\RequirePackage{coco-kernel}
\RequirePackage{xkeyval}
\let\usescript\relax
\define@key{coco-script.sty}{usescript}{\def\usescript{#1}}
\ProcessOptionsX

\RequirePackage[quiet]{fontspec}
\def\parse@script#1,#2,\relax{%
  \ccs@callback{#1}%
  \edef\@argii{#2}%
  \let\next\relax
  \ifx\@argii\@empty\else
    \def\next{\parse@script#2,\relax}%
  \fi\next}

\ifx\usescript\relax\else
  \def\ccs@callback#1{\expandafter\global\expandafter\let\csname use@script@#1\endcsname\@empty}%
  \expandafter\parse@script\usescript,,\relax
\fi
\ccPackageInfo{Script}{Info}{Fonts loaded: \meaning\usescript}
%    \end{macrocode}
% If babel's bidirectional feature is loaded without need, there might be errors, so we do some checks first:
%    \begin{macrocode}
\def\cc@bidi{}
\@tempswafalse
\ifx\usescript\relax\else
  \ifx\csname use@script@arabic\endcsname\@empty\@tempswatrue
  \else\ifx\csname use@script@hebrew\endcsname\@empty\@tempswatrue
    \else\ifx\csname use@script@amharic\endcsname\@empty\@tempswatrue
      \else\ifx\csname use@script@ethiop\endcsname\@empty\@tempswatrue
        \else\ifx\csname use@script@syriac\endcsname\@empty\@tempswatrue
          \fi\fi\fi\fi\fi\fi
\if@tempswa\def\cc@bidi{,bidi=basic}\fi
\RequirePackage[silent\cc@bidi]{babel}
%    \end{macrocode}
%
%
% \section{Fallback fonts}
%
% \begin{macro}{\ccsTestFont} is used to test the currently active
%   font family. For that, we compare the base name of
%   \lstinline{\f@family} with the (fully expanded) value given in the
%   first argument.
%   \begin{ArgList}
%   \item[1] is the comparison value that is testes against \LaTeX's
%     \lstinline{\f@family}.
%   \item[2] is the \lstinline{true} branch, executed if the base name
%     of \InlineArg{1} matches against the base name
%     \lstinline{\f@family}.
%   \item[3] is the \lstinline{else} branch.
%   \end{ArgList}
%    \begin{macrocode}
\def\ccsTestFont#1#2#3{\edef\@argi{#1}\expandafter\expandafter\expandafter\ccs@testfont\expandafter\f@family\expandafter.\expandafter\@nil\@argi.\@nil{#2}{#3}\@nil}
\def\ccs@testfont #1.#2\@nil#3.#4\@nil#5#6\@nil{\expandafter\ifnum\pdf@strcmp{#1}{#3}=\z@\relax#5\else#6\fi}
%    \end{macrocode}
% \end{macro}
% Comparison values of the three basic font families of LateX
% (\texttt{roman}, \texttt{sans-serif} and \texttt{monospace}) are
% defined after all packages are loaded. Macros for comparing Custom
% font families need to be defined manually.
%    \begin{macrocode}
\AddToHook{begindocument}{%
%    \end{macrocode}
% \begin{macro}{\ccs@rmdefault} holds the default roman font
%    \begin{macrocode}
  \begingroup\rmfamily\xdef\ccs@rmdefault{\f@family}\endgroup%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccs@sfdefault} holds the default sans-serif font
%    \begin{macrocode}
  \begingroup\sffamily\xdef\ccs@sfdefault{\f@family}\endgroup%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccs@ttdefault} holds the default monospace font
%    \begin{macrocode}
  \begingroup\ttfamily\xdef\ccs@ttdefault{\f@family}\endgroup%
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Default Fallback Font: Noto}
%
% The default fall backfont is the NotoSans Font Family
%    \begin{macrocode}
\newfontfamily\fallbackfont{NotoSerif-Regular.ttf}%
[BoldFont = NotoSerif-Bold.ttf,%
 ItalicFont = NotoSerif-Italic.ttf,%
 BoldItalicFont = NotoSerif-BoldItalic.ttf,%
 Path = ./fonts/Noto/Serif/,%
 WordSpace = 1.25]
\newfontfamily\sffallbackfont{NotoSans-Regular.ttf}%
[BoldFont = NotoSans-Bold.ttf,%
 ItalicFont = NotoSans-Italic.ttf,%
 BoldItalicFont = NotoSans-BoldItalic.ttf,%
 Path = ./fonts/Noto/Sans/,%
 WordSpace = 1.25]
\newfontfamily\ttfallbackfont{NotoSansMono-Regular.ttf}%
[BoldFont = NotoSansMono-Bold.ttf,%
 ItalicFont = NotoSansMono-Light.ttf,%
 BoldItalicFont = NotoSansMono-SemiBold.ttf,%
 Path = ./fonts/Noto/Mono/,%
 WordSpace = 1.25]
\DeclareTextFontCommand\textfallback{\fallbackfont}
\DeclareTextFontCommand\textsffallback{\sffallbackfont}
\DeclareTextFontCommand\textttfallback{\ttfallbackfont}
%    \end{macrocode}
%
%
% \subsection{Emojis}
%
% A font and a text command for using plain, black emojis.
%    \begin{macrocode}
\newfontfamily\emojifont{NotoEmoji-Regular.ttf}%
[BoldFont = NotoEmoji-Bold.ttf,%
 Path = ./fonts/Noto/Emoji/]
\DeclareTextFontCommand\textemoji{\emojifont}
%    \end{macrocode}
%
%
% \subsection{Support for medieval scripts and special characters}
%
% \textbf{Warning:} Junicode provides supports only for the
% \lstinline{rm} font family!
%    \begin{macrocode}
\babelfont{mdv}[%
Path=fonts/Junicode/,%
ItalicFont = Junicode-Italic.ttf,%
BoldFont = Junicode-Bold.ttf,%
BoldItalicFont = Junicode-BoldItalic.ttf,%
]{Junicode.ttf}
\def\mdvfont#1{{\mdvfamily#1}}
%    \end{macrocode}
%
%
% \subsection{International Phonetic Alphabet}
%
% Since the IPA character inventory seems to be included in the Noto
% fonts, we simply define the \UsageMacro{\ccTextipa} as a
% context-sensitive alias.
% \begin{macro}{\ccTextipa} is a text command for the International
%   Phonetic Alphabet. By default, the global Noto fallback font is
%   used and sensitive to \texttt{rm}, \texttt{sf}, and \texttt{tt}
%   contexts.
%
%   \textbf{Warning!} Noto has been chosen because it contains all IPA
%   symbols, but there are some short-commings: in italic contexts,
%   [a] and [ɑ] become indistinguishable for roman and hardly
%   distinguishable in sans-serif contexts. Also, the bow used to bind
%   vowels is misplaced in NotoSerif. We therefore provide an easy way
%   to locally re-define alternative IPA fonts:
% \begin{macro}{\ccIpaFont} for roman contexts,
%    \begin{macrocode}
\let\ccIpaFont\fallbackfont
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIpaSfFont} for sans-serif contexts, and
%    \begin{macrocode}
\let\ccIpaSfFont\sffallbackfont
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIpaTtFont} for monospace contexts.
%    \begin{macrocode}
\let\ccIpaTtFont\ttfallbackfont
%    \end{macrocode}
% \end{macro}
% Those macros are used to select the appropriate IPA font inside the
% \UsageMacro{\ccTextipa} text command:
%    \begin{macrocode}
\DeclareTextFontCommand\ccTextipa{%
  \ccsTestFont{\ccs@rmdefault}
    {\ccIpaFont}
    {\ccsTestFont{\ccs@sfdefault}
      {\ccIpaSfFont}
      {\ccIpaTtFont}}}%
%    \end{macrocode}
% \end{macro}
%
%
% \section{Generic Fonts Declaration Mechanism}
%
% \begin{description}
% \item[\#1] Options passed to \lstinline|\babelprovide|
% \item[\#2] language
% \item[\#3] argument(s) passed to \lstinline|\babelfont{rm}|
% \item[\#4] argument(s) passed to \lstinline|\babelfont{sf}|
% \end{description}
%    \begin{macrocode}
\def\ccDeclareBabelFont{\cc@opt@empty\ccs@declare@babel@font}%
\def\ccs@declare@babel@font[#1]#2#3#4{%
  \expandafter\ifx\csname use@script@#2\endcsname\@empty
    \babelprovide[#1]{#2}%
    \message{^^J  [coco-script Loaded Script: #2]^^J}%
    %%
    \expandafter\gdef\csname ccs@babel@rm@font@#2\endcsname{#3}%
    \expandafter\gdef\csname ccs@babel@sf@font@#2\endcsname{#4}%
    \if!#2!\else
      \def\ccs@tempa{\babelfont[#2]{rm}}%
      \expandafter\expandafter\expandafter\ccs@tempa\csname ccs@babel@rm@font@#2\endcsname
    \fi
    \if!#3!\else
      \def\ccs@tempa{\babelfont[#2]{sf}}%
      \expandafter\expandafter\expandafter\ccs@tempa\csname ccs@babel@sf@font@#2\endcsname
    \fi
  \fi
}
%    \end{macrocode}
% Top level macro to declare a font alias.
% \begin{description}
% \item[\#1] font family alias
% \item[\#2] font family fallback
% \end{description}
%    \begin{macrocode}
\def\ccBabelAlias#1#2{%
  \ifx\usescript\relax\else
    \def\ccs@callback##1{%
      \expandafter\ifx\csname ccs@no@fallback@##1\endcsname\relax
        \expandafter\ifx\csname ccs@babel@#2@font@##1\endcsname\relax
          \PackageError
            {coco-script.sty}
            {\expandafter\string\csname #2family\endcsname\space for Language `##1' was not declared!}
            {You attempted to declare an alias towards a font family that has not been declared for the language `##1', yet.}%
        \else
          \def\ccs@tempa{\babelfont[##1]{#1}}%
          \expandafter\expandafter\expandafter\ccs@tempa\csname ccs@babel@#2@font@##1\endcsname
        \fi
      \else
        \PackageInfo{coco-script.sty}{^^J\space\space\space\space No fallback for `##1';^^J\space\space\space\space Skipping font family `#1'->`#2'}%
      \fi}%
    \expandafter\parse@script\usescript,,\relax
  \fi}

%    \end{macrocode}
%
%
% \section{Predefined script systems}
%
% \subsection{Support for Armenian script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{armenian}{[%
    Path=./fonts/Noto/Armenian/,
    BoldFont = NotoSerifArmenian-Bold.ttf,%
    WordSpace = 1.25]{NotoSerifArmenian-Regular.ttf}}
  {[%
    Path=./fonts/Noto/Armenian/,
    BoldFont = NotoSansArmenian-Bold.ttf,%
    WordSpace = 1.25]{NotoSansArmenian-Regular.ttf}%
  }
%    \end{macrocode}
% Legacy and backwards compatibility:
%    \begin{macrocode}
\def\armenian{\foreignlanuage{armenian}}
%    \end{macrocode}
%
%
% \subsection{Support for Chinese script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{chinese}{[%
    Path=./fonts/Noto/Chinese/,
    BoldFont = NotoSerifSC-Bold.otf,%
    WordSpace = 1.25]{NotoSerifSC-Regular.otf}}
  {[%
    Path=./fonts/Noto/Chinese/,
    BoldFont = NotoSansSC-Bold.otf,%
    WordSpace = 1.25]{NotoSansSC-Regular.otf}%
  }
%    \end{macrocode}
%
%
% \subsection{Support for Japanese script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{japanese}{[%
    Path=./fonts/Noto/Japanese/,
    BoldFont = NotoSerifJP-Bold.otf,%
    WordSpace = 1.25]{NotoSerifJP-Regular.otf}
  }{[%
    Path=./fonts/Noto/Japanese/,
    BoldFont = NotoSansJP-Bold.otf,%
    WordSpace = 1.25]{NotoSansJP-Regular.otf}
  }
%    \end{macrocode}
%
%
% \subsection{Support for Korean script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{korean}{[%
  BoldFont = NotoSerifKR-Bold.otf,%
  ItalicFont = NotoSerifKR-Regular.otf,%
  BoldItalicFont = NotoSerifKR-Medium.otf,%
  Path=./fonts/Noto/Korean/,%
  Script=CJK%
  ]{NotoSerifKR-Regular.otf}}
{[%
  BoldFont = NotoSansKR-Bold.otf,%
  ItalicFont = NotoSansKR-Regular.otf,%
  BoldItalicFont = NotoSansKR-Medium.otf,%
  Path=./fonts/Noto/Korean/,%
  Script=CJK%
  ]{NotoSansKR-Regular.otf}%
}
%    \end{macrocode}
%
%
% \subsection{Support for Hebrew script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{hebrew}{[%
    Renderer=Harfbuzz,%
    Scale=MatchUppercase,%
    Path=./fonts/Noto/Hebrew/,%
    Ligatures=TeX,%
    Script=Hebrew,%
    BoldFont = NotoSerifHebrew-Bold.ttf]{NotoSerifHebrew-Regular.ttf}%
}{[%
    Renderer=Harfbuzz,%
    Scale=MatchUppercase,%
    Path=./fonts/Noto/Hebrew/,%
    Ligatures=TeX,%
    Script=Hebrew,%
    BoldFont = NotoSansHebrew-Bold.ttf]{NotoSansHebrew-Regular.ttf}%
}
%    \end{macrocode}
%
%
% \subsection{Support for Arabic script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{arabic}{[%
    BoldFont = NotoNaskhArabic-Bold.ttf,%
    Path = ./fonts/Noto/Arabic/,%
    Script=Arabic%
    ]{NotoNaskhArabic-Regular.ttf}}
  {[%
    BoldFont = NotoSansArabic-Bold.ttf,%
    Path = ./fonts/Noto/Arabic/,%
    Script=Arabic%
    ]{NotoSansArabic-Regular.ttf}%
  }
%    \end{macrocode}
%
%
% \subsection{Support for Greek script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{greek}{[%
    BoldFont = NotoSerif-Bold.ttf,%
    ItalicFont = NotoSerif-Italic.ttf,%
    BoldItalicFont = NotoSerif-BoldItalic.ttf,%
    Path = ./fonts/Noto/Serif/,%
    Script=Greek,%
    WordSpace = 1.25
    ]{NotoSerif-Regular.ttf}}
  {[BoldFont = NotoSans-Bold.ttf,%
    ItalicFont = NotoSans-Italic.ttf,%
    BoldItalicFont = NotoSans-BoldItalic.ttf,%
    Path = ./fonts/Noto/Sans/,%
    Script=Greek,%
    WordSpace = 1.25%
    ]{NotoSans-Regular.ttf}%
  }
%    \end{macrocode}
%
%
% \subsection{Support for Ethiopian/Amharic script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{ethiop}{[%
    BoldFont = NotoSerifEthiopic-Bold.ttf,%
    ItalicFont = NotoSerifEthiopic-Regular.ttf,%
    BoldItalicFont = NotoSerifEthiopic-Bold.ttf,%
    Path = ./fonts/Noto/Ethiop/,%
    WordSpace = 1.25
    ]{NotoSerifEthiopic-Regular.ttf}}
  {[BoldFont = NotoSansEthiopic-Bold.ttf,%
    ItalicFont = NotoSansEthiopic-Regular.ttf,%
    BoldItalicFont = NotoSansEthiopic-Bold.ttf,%
    Path = ./fonts/Noto/Ethiop/,%
    WordSpace = 1.25%
    ]{NotoSansEthiopic-Regular.ttf}%
  }
\ccDeclareBabelFont{amharic}{[%
    BoldFont = NotoSerifEthiopic-Bold.ttf,%
    ItalicFont = NotoSerifEthiopic-Regular.ttf,%
    BoldItalicFont = NotoSerifEthiopic-Bold.ttf,%
    Path = ./fonts/Noto/Ethiop/,%
    WordSpace = 1.25
    ]{NotoSerifEthiopic-Regular.ttf}}
  {[BoldFont = NotoSansEthiopic-Bold.ttf,%
    ItalicFont = NotoSansEthiopic-Regular.ttf,%
    BoldItalicFont = NotoSansEthiopic-Bold.ttf,%
    Path = ./fonts/Noto/Ethiop/,%
    WordSpace = 1.25%
    ]{NotoSansEthiopic-Regular.ttf}%
  }
%    \end{macrocode}
%
%
% \subsection{Support for Georgian script}
%
%    \begin{macrocode}
\ccDeclareBabelFont{georgian}{%
  [%
    Path = ./fonts/Noto/Georgian/,%
    BoldFont = NotoSerifGeorgian-Bold.ttf,%
    ItalicFont = NotoSerifGeorgian-Regular.ttf,%
    BoldItalicFont = NotoSerifGeorgian-Bold.ttf,%
    Scale=0.85%
  ]{NotoSerifGeorgian-Regular.ttf}%
}{%
  [%
    Path = ./fonts/Noto/Georgian/,%
    BoldFont = NotoSerifGeorgian-Bold.ttf,%
    ItalicFont = NotoSerifGeorgian-Regular.ttf,%
    BoldItalicFont = NotoSerifGeorgian-Bold.ttf,%
    Scale=0.85%
  ]{NotoSerifGeorgian-Regular.ttf}%
}
%    \end{macrocode}
%
%
% \subsection{Support for Syrian script}
%
% Since Babel does not support the Syrian script natively, we create a
% \lstinline{babel-syriac.ini} file and include it, if it is
% needed. If we don't, the kerning and ligatures of Syriac text will
% be off.
%
% Please note that due to the restrictions of the
% \lstinline{listings}-Package, some Unicode characters cannot be
% displayed correctly in the documentation of the following code.
% Therefore, Syriac letters appear as ``x'' in the following source
% code listing.
%    \begin{macrocode}
\expandafter\ifx\csname use@script@syriac\endcsname\@empty%
\RequirePackage{filecontents}
\begin{filecontents*}{babel-syriac.ini}
[identification]
charset = utf8
version = 0.1
date = 2019-08-25
name.local = ܠܫܢܐ ܣܘܪܝܝܐ
name.english = Classical Syriac
name.babel = classicalsyriac
tag.bcp47 = syc
tag.opentype = SYR
script.name = Syriac
script.tag.bcp47 = Syrc
script.tag.opentype = syrc
level = 1
encodings = 
derivate = no
[captions]
[date.gregorian]
[date.islamic]
[time.gregorian]
[typography]
[characters]
[numbers]
[counters]
\end{filecontents*}
\fi
%    \end{macrocode}
% Now, we can create the fallback font and import the newly created ini file:
%    \begin{macrocode}
\ccDeclareBabelFont[import=syriac]{syriac}{[%
    BoldFont = NotoSansSyriac-Black.ttf,%
    ItalicFont = NotoSansSyriac-Regular.ttf,%
    BoldItalicFont = NotoSansSyriac-Black.ttf,%
    Path = ./fonts/Noto/Syriac/,%
    WordSpace = 1.25
    ]{NotoSansSyriac-Regular.ttf}}
  {[BoldFont = NotoSansSyriac-Black.ttf,%
    ItalicFont = NotoSansSyriac-Regular.ttf,%
    BoldItalicFont = NotoSansSyriac-Black.ttf,%
    Path = ./fonts/Noto/Syriac/,%
    WordSpace = 1.25%
    ]{NotoSansSyriac-Regular.ttf}%
  }
%    \end{macrocode}
%    \begin{macrocode}[numbers=none,gobble=1]
%</script>
%    \end{macrocode}
