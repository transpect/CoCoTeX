% \chapter{transpect-kernel.dtx}
% This file provides the object-oriented interfaces for all other
% transpect-tex modules.
%    \begin{macrocode}[gobble=1]
%<*kernel>
%    \end{macrocode}
% \paragraph*{Preamble and Package Options}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2018/12/01]
\ProvidesPackage{transpect-kernel}
    [\filedate \fileversion le-tex transpect kernel]
%    \end{macrocode}
% % The \lstinline{debug} option triggers the output of additional
% information messages to the shell.
%    \begin{macrocode}
\newif\if@tp@debug \@tp@debugfalse
\DeclareOption{debug}{\global\@tp@debugtrue}%
\ProcessOptions
%    \end{macrocode}
% \paragraph*{Hard dependencies}
%    \begin{macrocode}
\RequirePackage{etoolbox}
%    \end{macrocode}
% \section{Exception handlers}
%
% \begin{macro}{\tpKernelDebugMsg}
%   is used to print debug messages iff the \lstinline{debug} class
%   option is set.
%    \begin{macrocode}
\def\tpKernelDebugMsg#1{\if@tp@debug\message{[tp Kernel Debug]\space\space#1^^J}\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpPackageError}
%   is a macro to create error messages specific to the Framework. \#1
%   is the module, \#2 is the type of error, \#3 is the immediate
%   error message, \#4 is the help string.
%    \begin{macrocode}
\def\tpPackageError#1#2#3#4{%
   \GenericError{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      [tp #1 #2 Error] #3%
   }{}{#4}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpPackageWarning}
%   is a macro to create warnings specific to the Framework. \#1
%   is the module, \#2 is the type of error, \#3 is the immediate
%   warning message.
%    \begin{macrocode}
\def\tpPackageWarning#1#2#3{%
   \GenericWarning{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      [tp #1 #2 Warning] #3%
   }%
}
%    \end{macrocode}
% \end{macro}
% \section{Containers}
%
% Containers are the package's core data structure. They are basicly
% sets of properties that are processed in the same way.
%
% \begin{macro}{\tpDeclareContainer}
%   is the constructor for new Containers. \#1 is the Container's
%   name, \#2 its body which conists of Component and Property
%   declarations.
%    \begin{macrocode}
\long\def\tpDeclareContainer#1#2{%
  \@namedef{tp@container@#1}{}%
  \@namedef{tp@cur@cont}{#1}%
%    \end{macrocode}
% We want the declarator macros to be only allowed inside the \lstinline{\tpDeclareContainer} macro.
%    \begin{macrocode}
  \begingroup
%    \end{macrocode}
% \begin{macro}{\tpInherit}
% The inherit mechanism is dynamic, i.e., we can load multiple type
% declarations from multiple containers at once.
%    \begin{macrocode}
    \def\tpInherit ##1 from ##2;{\@tp@inherit{##1}{##2}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpDeclareType}
% Each Container is defined by the data types it provides. These data
% types are declared with this macro. The first argument \#\#1 is the
% name of the data type. The second argument \#\#2 is a list of code
% that is specific to this type, usually something like Component or
% Property declarations, handlers, and so forth.
%    \begin{macrocode}
    \long\def\tpDeclareType##1##2{\csgappto{tp@type@##1@#1}{##2}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpDeclareEnv}
%   Each container usually is realised as a {\LaTeX} environment. The
%   \lstinline{\tpDeclareEnv} macro is used to set up this
%   environment. Usually, the environment has the same name as the
%   Container. With the optional argument \#\#1 you can override the
%   environment's name.  However, keep in mind that the Container's
%   name is not changed by re-naming the corresponding
%   environment. \#\#2 is used for the stuff done at the beginning of
%   the environment, \#\#3 for the stuff done at the end.
%
%   In the begin part, the Types declared in the Container
%   declaration's body should be evaluated using the
%   \lstinline{\tpEvalType} macro, see below.
%    \begin{macrocode}
    \def\tpDeclareEnv{\@ifnextchar [{\tp@declare@env}{\tp@declare@env[#1]}}%]
    \def\tp@declare@env[##1]##2##3{\csgdef{##1}{\global\let\reserved@cont\tp@cur@cont\def\tp@cur@cont{#1}##2}\csgdef{end##1}{##3}\global\let\tp@cur@cont\reserved@cont}%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
    \def\x{%
      #2%
    }%
  \expandafter\x\endgroup
}
\@onlypreamble\tpDeclareContainer
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpEvalType}
%   calls the Declaration list for data Type \#2. With optional \#1
%   the Container Class can be overriden.
%    \begin{macrocode}
\def\tpEvalType{\tp@opt@curcont\tp@eval@type}
\def\tp@eval@type[#1]#2{%
  \expandafter\ifx\csname tp@type@#2@#1\endcsname\relax
    \tpPackageError{Kernel}{Class}
    {Data Type #2 in Container #1 undefined!}
    {You try to evaluate a data type `#2' from container `#1', but that data type has not been declared.}%
  \else
    \tpKernelDebugMsg{Evaluating tp@type@#2@#1:^^J \expandafter\meaning\csname tp@type@#2@#1\endcsname}%
    \csname tp@type@#2@#1\endcsname
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpCheckParent}
%   checks if a Container \#1 is declared so that another container
%   \#2 can inherit.
%    \begin{macrocode}
\def\tpCheckParent#1#2{%
  \expandafter\ifx\csname tp@container@#1\endcsname\relax
    \tpPackageError{Kernel}{Class}
    {Parent Container `#1' undeclared}
    {You tried to make a Container named `#2' inherit from a Container named `#1', but a Container with that name does not exist.\MessageBreak
     Please make sure that parent Containers are declared before their descendents.}%
  \else
    \@namedef{tp@parent@#2}{#1}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@tp@inherit}
% is the low-level inherit function. \#1 is a comma-separated list of things
% to be inherited, and \#2 is the Container-list that should be
% inherited from, and \#3 is the name of the descending Container.
%    \begin{macrocode}
\def\@tp@inherit#1#2#3{\@tp@parse@inherit #1,,\@nil #2,,\@nil #3\@@nil}
%    \end{macrocode}
% low-level function to recursively parse the parameters of the
% \lstinline{\@tp@inherit} macro, above.
%    \begin{macrocode}
\def\@tp@parse@inherit #1,#2,\@nil #3,#4,\@nil #5\@@nil{%
  \let\next\relax
  \if!#1!\else
    \if!#3!\else
      \tp@do@inherit{#1}{#3}{#5}%
      \def\@argii{#2}\def\@argiv{#4}%
      \ifx\@argii\@empty
        \ifx\@argiv\@empty\else
          \def\next{\@tp@parse@inherit #1,,\@nil #4,\@nil #5\@@nil}%
        \fi
      \else
        \ifx\@argiv\@empty
          \def\next{\@tp@parse@inherit #2,\@nil #3,,\@nil #5\@@nil}%
        \else
          \def\next{%
            \@tp@parse@inherit #1,,\@nil #4,\@nil #5\@@nil
            \@tp@parse@inherit #2,\@nil #3,#4,\@nil #5\@@nil
          }%
        \fi\fi\fi\fi
  \next}
%    \end{macrocode}
% Ultimately, this function is called for each Type--Container
% combination invoked by the \lstinline{\tpInherit} macro.
%    \begin{macrocode}
\def\tp@do@inherit#1#2#3{%
  \tpKernelDebugMsg{#3 inherits #1 from #2.}%
  \tpCheckParent{#2}{#3}%
  \expandafter\ifx\csname tp@type@#1@#2\endcsname\relax
    \tpPackageError{Kernel}{Type}{Type `#1' was not declared}{Type `#1' was not declared for Container `#2'.}%
  \else
    \edef\x{\noexpand\csgappto{tp@type@#1@#3}}%
    \expandafter\expandafter\expandafter\x\expandafter\expandafter\expandafter{\csname tp@type@#1@#2\endcsname}%
    \tpKernelDebugMsg{value tp@type@#1@#3:^^J \expandafter\meaning\csname tp@type@#1@#3\endcsname}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \section{Components}
%
% \subsection{Simple Components}
% ``Simple Components'' are basicly data storages. They are used
% within Containers to obtain data and store them for further
% processing at the end of the Container, or even beyond.
%
% \begin{macro}{\tpDeclareComp}
% defines simple component macros.
% \begin{description}
% \item[\#1] is the Component's identifier.
%   The internal macro that is used to store the Component's value is
%   \lstinline{\csname tp@<current Container name>@<#1>\endcsname}. If omitted, \#1 is the same as \#2.
% \item[\#2] is the Component's name.
% \item[\#3] is code that is executed \textit{before} assignment of the user's value
% \item[\#4] is code that is executed \textit{after} assignment of the user's value
% \end{description}
%    \begin{macrocode}
\def\tpDeclareComp{\@dblarg\@tpDeclareComp}
\def\@tpDeclareComp[#1]#2#3#4{%
  \ltx@LocalExpandAfter\global\expandafter\let\csname tp@\tp@cur@cont @#1\endcsname\relax
  \expandafter\long\expandafter\def\csname tp#2\endcsname##1{%
    #3\expandafter\long\expandafter\def\csname tp@\tp@cur@cont @#1\endcsname{##1}\ignorespaces#4}%
}
%    \end{macrocode}
% \end{macro}
% Once declared, a component can be set in two ways: The first way is
% to use \lstinline{\tp<name>} with one argument for its value. The
% second, preferred, way is to use the \lstinline{\tpComp} macro which
% takes two arguments: \#1 is the name of the Component, \#2 is the
% value. This macro checks whether an Component of name \#1 has
% actually been declared and does so, if not.
% \begin{macro}{\tpComp}
%   This is the preferred way to fill a Component with content. \#1 is
%   the Component's name, \#2 is the value.
%    \begin{macrocode}
\long\protected\def\tpComp#1#2{%
  \ifx\tp@is@counted\relax
    \ifcsdef{tp@\tp@cur@cont @#1}{}
      {\tp@def@counted@comp{\tp@cnt@grp-#1-\expandafter\the\csname \tp@cnt@grp-Cnt\endcsname}{#1}{}{}}%
    \csgdef{tp@\tp@cur@cont @\tp@cnt@grp-#1-\expandafter\the\csname \tp@cnt@grp-Cnt\endcsname}{#2}%
  \else
    \ifcsdef{tp@\tp@cur@cont @#1}{}{\tpDeclareComp{#1}{}{}}%
    \csname tp#1\endcsname{#2}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpUseComp} is a high level command to return (or
%   print) the material stored as a Component with the name \#1.
%    \begin{macrocode}
\def\tpUseComp#1{\csname tp@\tp@cur@cont @#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpGetComp} is a high level command to return the
%   contents stored in a Component of name \#1 as a paragraph iff the
%   Component is non-empty or \lstinline{\relax}.
%    \begin{macrocode}
\def\tpGetComp#1{\tpIfComp{#1}{\tpUseComp{#1}\par}{}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpIfComp} is a high level macro that executes \#2 if
%   the Component macro \#1 is used in a Container (empty or
%   non-empty), and \#3 if not.
%    \begin{macrocode}
\long\def\tpIfComp#1#2#3{\expandafter\ifx\csname tp@\tp@cur@cont @#1\endcsname\relax#3\else#2\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpIfComp} is a high level macro that executes \#2 if
%   the Component macro \#1 is empty (or \lstinline|{}|) within its
%   Container, and \#3 if it is either not existant or non-empty.
%    \begin{macrocode}
\long\def\long@empty{}
\long\def\tpIfCompEmpty#1#2#3{\expandafter\ifx\csname tp@\tp@cur@cont @#1\endcsname\long@empty#2\else#3\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tp@check@empty} handles the distinction between empty
%   and un-used components: First, check if \#4\#3 is set (=anything
%   but \lstinline{\relax}). If it is set, check if it is empty. If
%   empty, set \lstinline{#4#3} to \lstinline{\relax}, meaning further
%   occurences of \lstinline|\IfComp{#4#3}| will execute the
%   \lstinline{else} branch. If \lstinline{#4#3} is non-empty, do nothing.
%
%   If \lstinline{#4#3} is already \lstinline{\relax}, check if the
%   fallback \lstinline{#1#3} is set. If so, make \lstinline{#4#3} an
%   alias of \lstinline{#1#3}. If not, do nothing.
%
%   Optional \#1 is the prefix of the fallback component, \#2 is the
%   Container name, \#3 is the name of the Component, \#4 is the
%   Override's prefix.
%    \begin{macrocode}
\def\tp@check@empty{\tp@opt@empty\@tp@check@empty}%]
\def\@tp@check@empty[#1]#2#3#4{%
   \tpIfComp{#4#3}
     {\tpIfCompEmpty{#4#3}
       {\expandafter\global\expandafter\let\csname tp@#2@#4#3\endcsname\relax}
       {}}
     {\tpIfComp{#1#3}
       {\expandafter\expandafter\expandafter\let\expandafter\csname tp@#2@#4#3\expandafter\endcsname\csname tp@#2@#1#3\endcsname}
       {}}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Counted Components}
%
% Counted Components are Components that may occur in the same
% Container multiple times. They may be multiple instances of
% single-macro Components, or recurring collections of multiple
% Components, called \textbf{Component Groups}.
%
% \subsubsection{Component Groups}\label{sec:kernel:compgroups}
% \begin{macro}{\tpDeclareComponentGroup} is a user-level macro to
%   declare a new Component Group with the name \#1 and the body \#2.
%    \begin{macrocode}
\def\tpDeclareComponentGroup#1#2{%
  \ifcsdef{#1-Cnt}{}{\expandafter\newcount\csname #1-Cnt\endcsname}%
  \csdef{#1}{\expandafter\tp@opt@empty\csname @#1\endcsname}%
  \csdef{@#1}[##1]{%
    \def\tp@cnt@grp{#1}%
    \expandafter\global\expandafter\advance\csname #1-Cnt\endcsname\@ne
    \if!##1!\else
      \csgdef{tp@\tp@cur@cont @#1-\expandafter\the\csname #1-Cnt\endcsname @attrs}{##1}\fi
    #2%
  }%
  \csdef{end#1}{{\tpToggleCountedCond\csname tp@compose@group@#1\endcsname}}%
}
\def\tpGroupHandler#1#2{%
  \ifcsdef{@#1}
    {\ifcsdef{tp@compose@group@#1}
      {\csgappto{tp@compose@group@#1}{#2}}
      {\csgdef{tp@compose@group@#1}{#2}}}
    {\tpPackageError{Kernel}{Type}{Component Group `#1' unknown!}{You tried to declare a Group Handler for a Component Group that has not been declared, yet!}}%
}
%\@onlypreamble\tpDeclareComponentGroup
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tp@cnt@grp} is a designated group name. Counted
%   Components of the same group use the same counter.
%    \begin{macrocode}
\let\tp@cnt@grp\@empty
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Iterating over Component Groups}
%
% The following two macros iterate over all instances of a Component
% Group \#1 in the current Container and applies for each instance the
% Property \#2. The result is appended to the the Collector Component
% \#3, if and only if that Component is not yet set for the current
% Container at the time of the first iteration.
%
% While the first macro only writes the Property \textit{definition}
% into the Collector Component, the second fully expands the macros inside the
% Property and stores the result in Component \#3.
%
% Use the former to print and the latter to further process the
% respective results.
% \begin{macro}{\tpCurCount} stores the number of the current instance
%   of a Counted Component. Use this in the declarations of Properties
%   that are expanded within the Component Group.
%    \begin{macrocode}
\newcount\tpCurCount
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpComposeCollection} is used to create a unexpanded
%   Collection Component \#3 from all instances of Component Group \#1
%   using the instructions given by property \#2.
%    \begin{macrocode}
\def\tpComposeCollection#1#2#3{%
  \tpIfComp{#3}{}{%
    \ifcsdef{#1-Cnt}{%
      \expandafter\ifnum\csname #1-Cnt\endcsname > \z@\relax
        \edef\tp@iterate@res{%
          \noexpand\bgroup
            \noexpand\def\noexpand\tpTotalCount{\the\csname #1-Cnt\endcsname}%
            \noexpand\tpToggleCountedCond
            \noexpand\def\noexpand\tp@cnt@grp{#1}}%
          \expandafter\@tempcntb\csname #1-Cnt\endcsname
          \tp@iterate{\@tempcnta}{\@ne}{\@tempcntb}{%
            \edef\@tempb{%
              %% top-level counter for user interaction
              \noexpand\tpCurCount=\the\@tempcnta
              %% internal counter for macro grabbing
              \noexpand\csname #1-Cnt\endcsname=\noexpand\tpCurCount
              \noexpand\tpUseProperty{#2}}%
            \expandafter\expandafter\expandafter\def
            \expandafter\expandafter\expandafter\tp@iterate@res
            \expandafter\expandafter\expandafter{\expandafter\tp@iterate@res\@tempb}%
          }%
          \expandafter\def\expandafter\tp@iterate@res\expandafter{\tp@iterate@res\egroup}%
        \expandafter\csname tp#3\expandafter\endcsname\expandafter{\tp@iterate@res}%
\message{^^J==> composed \string\ tp@\tp@cur@cont @#3: \expandafter\meaning\csname tp@\tp@cur@cont @#3\endcsname}%\STOPP
      \fi
    }{}}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpApplyCollection}
%   is an alternative version of \lstinline{\tpComposeCollection} and fully
%   expands the Property \#2 before it is stored inside the Component \#3.
%    \begin{macrocode}
\def\tpApplyCollection#1#2#3{%
  \tpIfComp{#3}{}
    {\tp@apply@collection{#1}{#2}%
     \expandafter\csname tp#3\expandafter\endcsname\expandafter{\tp@iterate@res}%
   }%
}
%    \end{macrocode}
% \end{macro}
% \#1 is the group name, \#2 is the property to format the collection
%    \begin{macrocode}
\def\tp@apply@collection#1#2{%
  \begingroup
    \global\let\tp@iterate@res\relax
    \edef\tpTotalCount{\the\csname #1-Cnt\endcsname}%
    \tp@iterate{\@tempcnta}{\@ne}{\tpTotalCount}{%
      \bgroup
        \tpToggleCountedCond
        \def\tp@cnt@grp{#1}%
        \csname #1-Cnt\endcsname=\the\@tempcnta
        \tpCurCount=\the\@tempcnta
        \protected@xdef\@tempb{\csname tp@\tp@cur@cont @#2\endcsname}%
        \@temptokena \expandafter{\@tempb}%
        \def\@tempc{\csgappto{tp@iterate@res}}%
        \expandafter\@tempc\expandafter{\@tempb}%
      \egroup
    }%
  \endgroup
  \message{^^J==> applied #1 with #2: \meaning\tp@iterate@res}%\STOPP
}
%    \end{macrocode}
% 
%    \begin{macrocode}
\def\tp@comp@def[#1]#2#3#4{%
  \tp@apply@collection{#3}{#4}%
  \ifx\tp@iterate@res\relax
    #1\let#2\relax%
  \else
    \def\@tempa{#1\def#2}%
    \expandafter\@tempa\expandafter{\tp@iterate@res}%
  \fi
}
\def\tpCompDef{\tp@comp@def[]}
\def\tpCompGDef{\tp@comp@def[\global]}

%    \end{macrocode}
%
% \subsubsection{Declaring Counted Component}
%
% \begin{macro}{\tpDeclareCountedComp}
%   is a user-level macro to create a new Counted Component. \#1 is
%   the user-level name of the Component, \#2 is the internal name.
%    \begin{macrocode}
\def\tpDeclareCountedComp#1{%
  \tp@def@counted@comp
    {\tp@cnt@grp-#1-\expandafter\the\csname \tp@cnt@grp-Cnt\endcsname}
    {#1}
    {}
    {\expandafter\global}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tp@def@counted@comp}
%   registers counter dependent Components. \#1 is the internal name
%   of the Component which is composed out of the group name, the
%   value of the group counter and the user-level macro name \#2; \#3
%   is some custom code passed to the second argument of
%   \lstinline{\tpDeclareComp}; and \#4 is a modifier to the internal
%   macro definition.
%    \begin{macrocode}
\def\tp@def@counted@comp#1#2#3#4{%
  \tpDeclareComp[#1]{#2}
    {\bgroup#3\expandafter\global}
    {\def\@tempa{{@tp@reset@components@\tp@cur@cont}}%
     \edef\@tempb{\noexpand\csgundef{tp@\noexpand\tp@cur@cont @#1}}%
     \expandafter\expandafter\expandafter\csgappto\expandafter\@tempa\expandafter{\@tempb}%
     \egroup}%
  #4\expandafter\long\expandafter\def\csname tp@\tp@cur@cont @#2\endcsname{\csname tp@\tp@cur@cont @#1\endcsname}%
  %%\csgappto{@tp@reset@components@\tp@cur@cont}{\csname tp@\tp@cur@cont @#2\endcsname{}}%
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Resetting Counted Component}
%
% \begin{macro}{\tp@reset@components}
%   is used to reset Counted Components to prevent later Containers of
%   a given type to feed the components from the previous Container of
%   the same type. Usually, this is prevented by keeping Component
%   definitions strictly local.
%
%   I some cases, however, Components may be declared globally, i.e.,
%   they may be re-used after the Container is ended. In this
%   so-called Asynchronuous Processing of Components, the reset should
%   be done at the very beginning of the next instance of the
%   container type to prevent bleeding of one container's components
%   into the next one, specifically if a container occurs more than
%   once in the same document.
%
%   \#1 is the type of the Component set.
%    \begin{macrocode}
\def\tp@reset@components#1{%
  \csname @tp@reset@components@#1\endcsname
  \global\cslet{@tp@reset@components@#1}\relax%
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Toggling Conditionals for Counted Components}
%
%
% \begin{macro}{\tpToggleCountedCond}
%   In order to process Counted Components, we need to re-define the
%   Conditionals in a way such that the Component is expanded twice
%   before the comparison takes place to correctly resolve the
%   Component counter.
%
%   \textbf{Warning!} Use this macro only within local groups!
%    \begin{macrocode}
\long\def\tpToggleCountedCond{%
  \let\tp@is@counted\relax
  \long\def\tpIfComp##1##2##3{%
    %\ifcsprotected{tp@\tp@cur@cont @##1}{##2}{##3}%
    %\expandafter\expandafter\expandafter\ifx\csname tp@\tp@cur@cont @##1\endcsname\relax##2\else##3\fi
    \expandafter\let\expandafter\@tempa\csname tp@\tp@cur@cont @##1\endcsname\relax
    \expandafter\expandafter\expandafter\ifx\@tempa\relax##3\else##2\fi%
    % \expandafter\def\expandafter\@tempa\expandafter{\csname tp@\tp@cur@cont @##1\endcsname}%
    % \expandafter\expandafter\expandafter\ifx\@tempa\relax##3\else##2\fi%
  }
  \long\protected\def\tpIfCompEmpty##1##2##3{%
    \expandafter\expandafter\expandafter\ifx\csname tp@\tp@cur@cont @##1\endcsname\long@empty ##2\else ##3\fi}}
%    \end{macrocode}
% \end{macro}
%
% \section{Hooks}
%
% Hooks are used to patch code into different parts of a Container's
% processing chain.
% \begin{macro}{\tpDeclareHook} registers a new hook. Optional \#1 is
%   the container for which the Hook is declared. If omitted, this
%   defaults to \lstinline{\tp@cur@cont}. \#2 is the Hook's user-level
%   name. Hooks always default to an empty string.
%    \begin{macrocode}
\def\tpDeclareHook{\tp@opt@curcont\tp@declare@hook}
\def\tp@declare@hook[#1]#2{\expandafter\global\expandafter\let\csname tp@hook@#1@#2\endcsname\@empty}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpAddToHook} adds new material to a Hook. If the hook
%   has not yet been declared, a tpDeclareHook for that hook is
%   applied first. In that case, use the optional \#1 to specify the
%   Container name that hook is intended for. If it is omitted, the
%   current Container is used. \#2 is the name of the hook the
%   material in \#3 is to be appended to.
%    \begin{macrocode}
\def\tpAddToHook{\tp@opt@curcont\tp@add@to@hook}
\def\tp@add@to@hook[#1]#2#3{%
  \expandafter\ifx\csname tp@hook@#1@#2\endcsname\relax
    \tpDeclareHook[#1]{#2}%
  \fi
  \csgappto{tp@hook@#1@#2}{#3}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpUseHook} expands the current state of the hook with
%   the name \#2 from Container \#1 (current Container if omitted).
%    \begin{macrocode}
\def\tpUseHook{\tp@opt@curcont\tp@use@hook}
\def\tp@use@hook[#1]#2{\csuse{tp@hook@#1@#2}}
%    \end{macrocode}
% \end{macro}
%
% \section{Properties}\label{sec:kernel:props}
% \subsection{Setting Properties}\label{sec:kernel:prop:set}
%
% \begin{macro}{\tpSetProperty}
%   is a user-level macro that provides the Property--Value interface
%   for Containers. \#1 is the name of the Property, \#2 is the Value
%   assigned to that Property.
%    \begin{macrocode}
\long\def\tpSetProperty#1#2{\long\csdef{tp@\tp@cur@cont @#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpPropertyLet} can be used to create an alias
%   Property \#1 of a given Property \#2. Is is equivalent to
%   \lstinline|\tpSetProperty{\#1}{\tpUseProperty{\#2}}|.
%    \begin{macrocode}
\long\def\tpPropertyLet#1#2{\long\csdef{tp@\tp@cur@cont @#1}{\csuse{tp@\tp@cur@cont @#2}}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpSetValProp}
%   is a variant of \lstinline{\tpSetProperty} that expands the value
%   \#2 \textit{once} before assigning it to the Property macro with
%   the name \#1. This can be used to assign the current value of a
%   variable macro, dimension, counter or length to a Property.
%    \begin{macrocode}
\long\def\tpSetValProp#1#2{\def\@tempa{\tpSetProperty{#1}}\expandafter\@tempa\expandafter{#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpSetPropertyX}
%   is another variant of \lstinline{\tpSetProperty}, but it
%   \textit{fully expands} the value defined in \#2 before the
%   Property is stored in the Property macro named \#1. Use this if
%   you need to use conditionals to determine the actual values of
%   Properties that otherwise expect fixed named or dimensional
%   values.
%    \begin{macrocode}
\long\def\tpSetPropertyX#1#2{\long\csedef{tp@\tp@cur@cont @#1}{#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpAddToDefault}
%   adds material to a Container's defaults; \#1 is the name of the
%   Container, \#2 is a block of Property assignments.
%    \begin{macrocode}
\long\def\tpAddToDefault#1#2{\csgappto{tp@#1@default}{#2}}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Using Properties}\label{sec:kernel:prop:use}
%
% \begin{macro}{\tpUseProperty}
%   is a user-level command to directly access a previously set Property.
%    \begin{macrocode}
\def\tpUseProperty#1{\csuse{tp@\tp@cur@cont @#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\tpUsePropEnv}
%   is a user-level command to access a previously set Property and make it an environment accessible to Property specific processing instrunctions (see below).
%    \begin{macrocode}
\def\tpUsePropEnv#1{\cslet{tp@#1@active}{\relax}\csuse{tp@\tp@cur@cont @#1}\csundef{tp@#1@active}}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Processing Instructions}\label{sect:tpPI}
%
% In general, processing instructions are commands that are only
% visible to a specific process and ignored by others. In
% \lstinline{transpect-tex}, Processing Instructions (PIs) are
% commands placed inside a Component that should only take effect when
% that Component is processed through a specific Property.
%
% \begin{macro}{\tpPI} is a Processing Instruction that executes \#2
%   when a Property with the name \#1 is currently processed with the
%   \lstinline{\tpUsePropEnv} macro.
%    \begin{macrocode}
\DeclareRobustCommand\tpPI[2]{\ifcsdef{tp@#1@active}{#2}{}}
%    \end{macrocode}
% \end{macro}
%
%
% \Deprecated TODO: Incorporate into the Container inheritance mechanism. Check if inheritance of Container Types is to be distinguished from inheritance of Properties and their Values!
% \begin{macro}{\tpCascadeProps}
%   recursivly loads a Container's own Properties, the Properties of
%   the Container's parent(s), and the default Properties of the top-level
%   Container. \#1 is the current Container's name, \#2 is the top-level
%   Container. 
%    \begin{macrocode}
\def\tpCascadeProps#1#2{%
  \csname tp@#2@default\endcsname
  \expandafter\ifx\csname tp@#2@#1@parent\endcsname\relax\else
    \expandafter\tp@inherit@props\expandafter{\csname tp@#2@#1@parent\endcsname}{#2}%
  \fi
  \csname tp@#2@#1@properties\endcsname
}
%    \end{macrocode}
% This low-level macro recursivly loads properties from parent
% namespaces, if they exist. \#1 is the parent (may be empty), \#2 is
% the macro family.
%    \begin{macrocode}
\def\tp@inherit@props#1#2{%
  \expandafter\ifx\csname tp@#2@#1@parent\endcsname\relax\else
    \edef\@tempa{\csname tp@#2@#1@parent\endcsname}%
    \expandafter\tp@inherit@props\expandafter{\@tempa}{#2}%
  \fi
  \csname tp@#2@#1@properties\endcsname
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Property Conditionals}\label{sec:kernel:prop:cond}
%
% \begin{macro}{\tpIfProp}
%   checks if a Property with the name \#1 is defined and
%   non-empty. If so, do \#2, otherwise do \#3.
%    \begin{macrocode}
\long\def\tpIfProp#1#2#3{\long\def\@tempa{}%
    \expandafter\ifx\csname tp@\tp@cur@cont @#1\endcsname\@tempa #3\else#2\fi
\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpIfPropVal}
%   checks if a Property \#1 expands to \#2.  If so, do \#3, otherwise
%   do \#4.
%    \begin{macrocode}
\long\def\tpIfPropVal#1#2#3#4{\long\def\@tempa{#2}%
  \expandafter\ifx\csname tp@\tp@cur@cont @#1\endcsname\@tempa\relax#3\else#4\fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
%
% \section{Helper macros}
% \subsection{Handling of Optional Arguments}
% Two simple internal macros to ease up the handling of optional
% arguments.
% \begin{macro}{\tp@opt@curcont} overrides Container Names with the optional argument.
%    \begin{macrocode}
\def\tp@opt@curcont#1{\@ifnextchar[{#1}{#1[\tp@cur@cont]}}%]
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tp@opt@empty} passes an empty string if the optional argument is missing.
%    \begin{macrocode}
\def\tp@opt@empty#1{\@ifnextchar[{#1}{#1[]}}%]
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tp@opt@second} passes the first mandatory argument to
%   the optional argument if the latter is missing.
%    \begin{macrocode}
\def\tp@opt@second#1{\def\@tempa[##1]##2{#1[##1\if!##1!##2\fi]{##2}}%
  \@ifnextchar[{\@tempa}{\@tempa[]}}%
%    \end{macrocode}
% \end{macro}
% \subsection{Iterators}
% \begin{macro}{\tp@iterate}
%   traverses in \#1-th steps (optional, defaults to $+1$) through
%   counter \#2 start at number \#3 until and including number \#4 and
%   do at every loop \#5 (from \lstinline{forloop.sty}):
%    \begin{macrocode}
\long\def\tp@iterate{\@ifnextchar[{\@tp@iterate}{\@tp@iterate[\@ne]}}%]
\long\def\@tp@iterate[#1]#2#3#4#5{%
  \advance#2 by #1\relax
  #2=#3\relax%
  \expandafter\ifnum#2>#4\relax%
  \else
    #5%
    \tp@iterate[#1]{#2}{\the#2}{#4}{#5}%
  \fi}%
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\csmean} displays the meaning of a control sequence with the name of \#1.
%    \begin{macrocode}
\def\csmean#1{\expandafter\meaning\csname#1\endcsname}%
%    \end{macrocode}
% \end{macro}
%
% \subsection{Attributes}
%
% Many macros and environments deal with optional arguments that are
% used to alter the behaviour of that macro or environment. The
% combination of a parameter and its set of possible values are calles
% \textbf{Attributes}. In this section, we define the parsers for
% those paramters.
%
% In order to catch the \lstinline{babel} package's messing with the
% quote symbol, we make sure it has the correct cat-code.
%    \begin{macrocode}
\begingroup
\catcode`"=12
%    \end{macrocode}
% \begin{macro}{\tpParseAttributes}
% High level wrapper for the attribute parser; \#1 is the parent node of the attribute, \#2 is the attribute chain
%    \begin{macrocode}
\gdef\tpParseAttributes#1#2{%
  \if!#1!\else
    \if!#2!\else
      \def\tp@cur@node{#1}%
      \@tp@parse@attributes #2,,\@nil
    \fi\fi}
%    \end{macrocode}
% \end{macro}
% The actual, recursively applying, parser comes in two parts:
% \begin{macro}{\@tp@parse@attributes}
%   parses the single attributes in an optional argument,
%    \begin{macrocode}
\gdef\@tp@parse@attributes #1,#2,\@nil{%
  \if!#1!\else
    \tp@parse@kv#1==\@nil
    \if!#2!\else
      \@tp@parse@attributes#2,\@nil
    \fi\fi}
\endgroup
%    \end{macrocode}
% \end{macro}
% and
% \begin{macro}{\tp@parse@kv}
% distinguishes between the parameter name and its value(s).
%    \begin{macrocode}
\gdef\tp@parse@kv#1=#2=#3\@nil{%
  \edef\@argii{#2}%
  \ifx\@argii\@empty
    \expandafter\let\csname tp@\tp@cur@node @attr@#1\endcsname\@empty%
  \else
    \ifx #2 =\else
      \expandafter\def\csname tp@\tp@cur@node @attr@#1\endcsname{#2}%
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
% \subsection{Style Classes}
%
% Style Classes are locally usable sub-Containers.
%
% \begin{macro}{\tpDeclareClass}
%   The top-level macro \lstinline|\tpDeclareClass[#1]{#2}[#3]{#4}|
%   has four arguments, two of which are optional. \#2 is the name of
%   the class. If this argument is empty, the special class name
%   \lstinline{default} is used. \#4 is the declaration block of the
%   class. This argument usually containsa set of property assignments
%   using the \lstinline|\tpSetProperty{<prop>}{<val>}| macro, see
%   Sect.~\ref{sec:kernel:props}. The first optional argument \#1 is
%   the Style Class' parent Container. Using parent Containers, you
%   can have Style Classes of the same name for different
%   (sub-)Containers, e.g., a \lstinline{default} class for each float
%   and heading Container. The second optional argument \#3 is the
%   parent Style Class. Properties from that Style Class are loaded
%   automatically prior to the loading of the current Style Class's
%   Properties. This applies recursively allowing for a cascading of
%   property values, as in CSS.
%    \begin{macrocode}
\long\def\tpDeclareClass{\@ifnextchar [{\@tp@set@class}{\@tp@set@class[default]}}%]
\long\def\@tp@set@class[#1]#2{\tp@opt@empty{\tp@set@class[#1]{#2}}}%
\long\gdef\tp@default@class@default{}
\long\def\tp@set@class[#1]#2[#3]#4{%
  \def\@argii{#2}\ifx\@argii\@empty\let\@argii\tp@str@default\fi%
  \if!#3!\else
    \expandafter\long\expandafter\def\csname tp@#1@class@\@argii @parent\endcsname{#3}%
  \fi
  \expandafter\long\expandafter\def\csname tp@#1@class@\@argii\endcsname{#4}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpUseClass}
%   is a user-level macro to expand and “activate” a Style Class'
%   Properties, those of its recursive ancestor Style Classes, and the
%   default Style Class respecting the current Container. \#1 is the
%   Style Class name, \#2 is the Container.
%    \begin{macrocode}
\def\tpUseClass#1#2{%
  \expandafter\ifx\csname tp@#2@class@#1\endcsname\relax
    \expandafter\ifx\csname tp@default@class@#1\endcsname\relax
      \PackageError{transpect.cls}{Class `#1' with scope `#2' not defined!}{Please declare the class `#1'!}%
    \fi
  \fi
  \csname tp@default@class@#1\endcsname%
  \expandafter\ifx\csname tp@#2@class@#1@parent\endcsname\relax\else
    \expandafter\tpUseClass\expandafter{\csname tp@#2@class@#1@parent\endcsname}{#2}%
  \fi
  \csname tp@#2@class@#1\endcsname}
% \end{macro}
%    \end{macrocode}
% \end{macro}
% \section{Legacy Functions}\Deprecated
%    \begin{macrocode}
 \def\tpNamespace#1{\def\tp@cur@cont{#1}}
%    \end{macrocode}
%    \begin{macrocode}[gobble=1]
%</kernel>
%    \end{macrocode}
