% \chapter{transpect-kernel.dtx}
% This file provides the object-oriented interfaces for all other
% transpect-tex modules.
%    \begin{macrocode}[gobble=1]
%<*kernel>
%    \end{macrocode}
% \paragraph*{Preamble and Package Options}
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2018/12/01]
\ProvidesPackage{transpect-kernel}
    [\filedate \fileversion le-tex transpect kernel]
%    \end{macrocode}
% % The \lstinline{debug} option triggers the output of additional
% information messages to the shell.
%    \begin{macrocode}
\newif\if@tp@debug \@tp@debugfalse
\DeclareOption{debug}{\global\@tp@debugtrue}%
\ProcessOptions
%    \end{macrocode}
% \paragraph*{Hard dependencies}
%    \begin{macrocode}
\RequirePackage{etoolbox}
%    \end{macrocode}
% \section{Exception handlers}
%
% \begin{macro}{\tpKernelDebugMsg}
%   is used to print debug messages iff the \lstinline{debug} class
%   option is set.
%    \begin{macrocode}
\def\tpKernelDebugMsg#1{\if@tp@debug\message{[tp Kernel Debug]\space\space#1^^J}\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpPackageError}
%   is a macro to create error messages specific to the Framework. \#1
%   is the module, \#2 is the type of error, \#3 is the immediate
%   error message, \#4 is the help string.
%    \begin{macrocode}
\def\tpPackageError#1#2#3#4{%
   \GenericError{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      [tp #1 #2 Error] #3%
   }{}{#4}%
}
%    \end{macrocode}
% \end{macro}
% \section{Containers}
%
% \begin{macro}{\tpDeclareContainer}
%  is the constructor for new Containers
% \begin{description}
% \item[\#1] Container name
% \item[\#2] Body
% \end{description}
%    \begin{macrocode}
\long\def\tpDeclareContainer#1#2{%
  \@namedef{tp@container@#1}{}%
  \@namedef{tp@cur@cont}{#1}%
%    \end{macrocode}
% We want the declarator macros to be only allowed inside the \lstinline{\tpDeclareContainer} macro.
%    \begin{macrocode}
  \begingroup
%    \end{macrocode}
% \begin{macro}{\tpInherit}
% The inherit mechanism is dynamic, i.e., we can load multiple type
% declarations from multiple containers at once.
%    \begin{macrocode}
    \def\tpInherit ##1 from ##2;{\@tp@inherit{##1}{##2}{#1}}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpDeclareType}
% Each Container is defined by the data types it provides. These data
% types are declared with this macro. The first argument \#\#1 is the
% name of the data type. The second argument \#\#2 is a list of code
% that is specific to this type, usually something like Component or
% Property declarations, handlers, and so forth.
%    \begin{macrocode}
    \def\tpDeclareType##1##2{%
      \expandafter\ifx\csname tp@type@##1@#1\endcsname\relax
        \@namegdef{tp@type@##1@#1}{##2}%
      \else
        \gcsappto{tp@type@##1@#1}{##2}%
      \fi
    }%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpDeclareEnv}
% Each container consists of a {\LaTeX} environment. The
% \lstinline{\tpDeclareEnv} macro is used to declare those
% environments, \#\#1 is used for the stuff done at the beginning of
% the environment, \#\#2 for the stuff done at the end. The
% environment's name is identical to the container's name.
%
% In the begin part, the Types declared in the Container declaration's
% body should be evaluated using the \lstinline{\tpEvalType} macro,
% see below.
%    \begin{macrocode}
    \def\tpDeclareEnv##1##2{\@namegdef{#1}{\def\tp@cur@cont{#1}##1}\@namegdef{end#1}{##2}}%
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
    \def\x{%
      #2%
    }%
  \expandafter\x\endgroup
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpEvalType}
%   calls the Declaration list for data Type \#1.
%    \begin{macrocode}
\def\tpEvalType#1{%
  \tpKernelDebugMsg{Evaluating tp@type@#1@\tp@cur@cont:^^J \expandafter\meaning\csname tp@type@#1@\tp@cur@cont\endcsname}%
  \csname tp@type@#1@\tp@cur@cont\endcsname
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpCheckParent}
%   checks if a Container \#1 is declared so that another container
%   \#2 can inherit.
%    \begin{macrocode}
\def\tpCheckParent#1#2{%
  \expandafter\ifx\csname tp@container@#1\endcsname\relax
    \tpPackageError{Kernel}{Class}
    {Parent Container `#1' undeclared}
    {You tried to make a Container named `#2' inherit from a Container named `#1', but a Container with that name does not exist.\MessageBreak
     Please make sure that parent Containers are declared before their descendents.}%
  \else
    \@namedef{tp@parent@#2}{#1}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\@tp@inherit}
% is the low-level inherit function. \#1 is a comma-separated list of things
% to be inherited, and \#2 is the Container-list that should be
% inherited from, and \#3 is the name of the descending Container.
%    \begin{macrocode}
\def\@tp@inherit#1#2#3{\@tp@parse@inherit #1,,\@nil #2,,\@nil #3\@@nil}
%    \end{macrocode}
% Function to recursively parse the parameters of the inherit macro, above.
%    \begin{macrocode}
\def\@tp@parse@inherit #1,#2,\@nil #3,#4,\@nil #5\@@nil{%
  \let\next\relax
  \if!#1!\else
    \if!#3!\else
      \tp@do@inherit{#1}{#3}{#5}%
      \def\@argii{#2}\def\@argiv{#4}%
      \ifx\@argii\@empty
        \ifx\@argiv\@empty\else
          \def\next{\@tp@parse@inherit #1,,\@nil #4,\@nil #5\@@nil}%
        \fi
      \else
        \ifx\@argiv\@empty
          \def\next{\@tp@parse@inherit #2,\@nil #3,,\@nil #5\@@nil}%
        \else
          \def\next{%
            \@tp@parse@inherit #1,,\@nil #4,\@nil #5\@@nil
            \@tp@parse@inherit #2,\@nil #3,#4,\@nil #5\@@nil
          }%
        \fi\fi\fi\fi
  \next}
%    \end{macrocode}
% Ultimately, this function is called for each Type-Container
% combination invoked by the \lstinline{\tpInherit} macro.
%    \begin{macrocode}
\def\tp@do@inherit#1#2#3{%
  \tpKernelDebugMsg{#3 inherits #1 from #2.}%
  \tpCheckParent{#2}{#3}%
  \expandafter\ifx\csname tp@type@#1@#2\endcsname\relax
    \tpPackageError{Kernel}{Type}{Type `#1' was not declared}{Type `#1' was not declared for Container `#2'.}%
  \else
    \edef\x{\noexpand\gcsappto{tp@type@#1@#3}}%
    \expandafter\expandafter\expandafter\x\expandafter\expandafter\expandafter{\csname tp@type@#1@#2\endcsname}%
    \tpKernelDebugMsg{value tp@type@#1@#3:^^J \expandafter\meaning\csname tp@type@#1@#3\endcsname}%
  \fi
}
%    \end{macrocode}
% \end{macro}
%
% \section{Components}
% \begin{macro}{\tpProvideComp}
% defines component macros that are only valid within their respective Container.
% \begin{description}
% \item[\#1] is the top-level component name
% \item[\#2] is code that is executed \textit{before} assignment of the user's value
% \item[\#3] is code that is executed \textit{after} assignment of the user's value
% \item[\#4] is the internal identifier. The macro that is build is \lstinline{\csname tp@<current Container name>@<id>\endcsname}
% \end{description}
%    \begin{macrocode}
\def\tpProvideComp#1#2#3#4{%
  \ltx@LocalExpandAfter\global\expandafter\let\csname tp@\tp@cur@cont @#4\endcsname\relax
  \expandafter\long\expandafter\def\csname #1\endcsname##1{%
    #2\expandafter\long\expandafter\def\csname tp@\tp@cur@cont @#4\endcsname{##1}\ignorespaces#3}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpProvideCountedComp}
% registers counter dependent Components. \#1
% is the overt name of the Component, \#2 is the internal name of the
% component, \#3 is the accessor name to be used with
% \lstinline{\tpUseComp} and the conditionals, \#4 is the counter
% register, \#5 is some custom code passed to the second argument of
% \lstinline{\tpProvideComp}, and \#6 is a modifier to the internal
% macro definition.
%    \begin{macrocode}
\def\tpProvideCountedComp#1#2#3#4#5#6{%
  \tpProvideComp{#1}
    {\bgroup#5\expandafter\global}
    {\def\@tempa{{@tp@reset@components}}%
     \edef\@tempb{%
       \noexpand\ltx@LocalExpandAfter\noexpand\global\noexpand\expandafter\noexpand\let
         \noexpand\csname tp@\noexpand\tp@cur@cont @#2-\the#4\noexpand\endcsname
         \noexpand\relax}%
     \expandafter\expandafter\expandafter\csgappto\expandafter\@tempa\expandafter{\@tempb}%
     \egroup}
    {#2-\the#4}%
  #6\expandafter\long\expandafter\def\csname tp@\tp@cur@cont @#3\endcsname{\csname tp@\tp@cur@cont @#2-\the#4\endcsname}%
  \csgappto{@tp@reset@components}{\csname tp@\tp@cur@cont @#3\endcsname}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpSetComp}
% When Namespaces are processed asynchronously, Componets may not be
% availeable inside Property definitions. In this case, this makro
% should be used, instead. \#1 is the Comp name, \#2 is the value.
%    \begin{macrocode}
\long\protected\def\tpSetComp#1#2{%
  \expandafter\ifx\csname tp@\tp@cur@cont @#1\endcsname\relax
    \ifx\tp@is@counted\relax
      \tpProvideCountedComp{tp#1}{\tp@cnt@grp-#1}{#1}{\csname \tp@cnt@grp-Cnt\endcsname}{}{}%
    \else
      \tpProvideComp{tp#1}{}{}{#1}%
    \fi
  \fi
  \csname tp#1\endcsname{#2}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpUseComp} is a
% high level command to use Data field \#1.
%    \begin{macrocode}
\def\tpUseComp#1{\csname tp@\tp@cur@cont @#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpGetComp} is a high level command to print Data
%   field \#1 in a paragraph if the Component is not empty or
%   \lstinline{\relax}.
%    \begin{macrocode}
\def\tpGetComp#1{\tpIfComp{#1}{\tpUseComp{#1}\par}{}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpIfComp} is a high level macro that executes \#2 if
%   the Component macro \#1 is given in its Namespace (empty or
%   non-empty), and \#3 if it is not given (i.e., not existant).
%    \begin{macrocode}
\long\def\tpIfComp#1#2#3{\expandafter\ifx\csname tp@\tp@cur@cont @#1\endcsname\relax#3\else#2\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpIfComp} is a high level macro that executes \#2 if
%   the Component macro \#1 is empty (or \lstinline|{}|) within its
%   Namespace, and \#3 if it is either not existant or non-empty.
%    \begin{macrocode}
\long\def\tpIfCompEmpty#1#2#3{\long\def\@tempa{}\expandafter\ifx\csname tp@\tp@cur@cont @#1\endcsname\@tempa#2\else#3\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tp@check@empty} handles the distinction between empty
%   and un-used components. Optional \#1 is the prefix of the fallback
%   component, \#2 is the namespace, \#3 is the name of the Component,
%   \#4 is the Override's prefix.
%    \begin{macrocode}
\def\tp@check@empty{\@ifnextchar[\@tp@check@empty{\@tp@check@empty[]}}%]
\def\@tp@check@empty[#1]#2#3#4{%
  \tpIfComp{#4#3}
    {\tpIfCompEmpty{#4#3}
      {\expandafter\global\expandafter\let\csname tp@#2@#4#3\endcsname\relax}
      {}}
    {\tpIfComp{#1#3}
      {\expandafter\expandafter\expandafter\let\expandafter\csname tp@#2@#4#3\expandafter\endcsname\csname tp@#2@#1#3\endcsname}
      {}}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\tpToggleCountedCond}
% In order to account for counted Components, we occasionally need to
% re-define the Component conditionals in a way such that the
% Component is expanded twice before the comparison takes place:
%    \begin{macrocode}
\long\def\tpToggleCountedCond{%
  \let\tp@is@counted\relax
  \long\protected\def\tpIfComp##1##2##3{%
    \expandafter\let\expandafter\@tempa\csname tp@\tp@cur@cont @##1\endcsname\relax
    \expandafter\expandafter\expandafter\ifx\@tempa\relax##3\else##2\fi}%
  \long\protected\def\tpIfCompEmpty##1##2##3{%
    \long\def\@tempa{}%
    \expandafter\let\expandafter\@tempb\csname tp@\tp@cur@cont @##1\endcsname\relax
    \expandafter\expandafter\expandafter\ifx\@tempb\@tempa ##2\else ##3\fi}}
%    \end{macrocode}
% \end{macro}
%
%
% \section{Helper macros}
%    \begin{macrocode}
\def\@namegdef{\global\@namedef}
\def\gcsappto{\global\csappto}

%    \end{macrocode}
% \subsection{Iterators}
% \begin{macro}{\tp@iterate}
%   traverses in \#1-th steps (optional, defaults to $+1$) through
%   counter \#2 start at number \#3 until and including number \#4 and
%   do at every loop \#5 (from \lstinline{forloop.sty}):
%    \begin{macrocode}
\long\def\tp@iterate{\@ifnextchar[{\@tp@iterate}{\@tp@iterate[\@ne]}}%]
\long\def\@tp@iterate[#1]#2#3#4#5{%
  \advance#2 by #1\relax
  #2=#3\relax%
  \expandafter\ifnum#2>#4\relax%
  \else
    #5%
    \tp@iterate[#1]{#2}{\the#2}{#4}{#5}%
  \fi}%
%    \end{macrocode}
% \end{macro}
% \section{Legacy Functions}
%    \begin{macrocode}
 \def\tpNamespace#1{\def\tp@cur@cont{#1}}
%    \end{macrocode}
%    \begin{macrocode}[gobble=1]
%</kernel>
%    \end{macrocode}
