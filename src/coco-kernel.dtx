% \chapter{coco-kernel.dtx}
%
%    \begin{macrocode}[numbers=none,gobble=1]
%<*kernel>
%    \end{macrocode}
%
% This file provides the object-oriented interfaces for all other
% {\CoCoTeX} modules.
%
% \section{Preamble}
%
%    \begin{macrocode}
\NeedsTeXFormat{LaTeX2e}[2018/12/01]
\ProvidesPackage{coco-kernel}
    [\filedate \fileversion cocotex kernel]
%    \end{macrocode}
%
%
% \subsection{Hard dependencies}
%
%    \begin{macrocode}
\RequirePackage{kvoptions-patch}
\RequirePackage{xkeyval}
\RequirePackage{etoolbox}
%    \end{macrocode}
% Default hook label for {\CoCoTeX} modules:
%    \begin{macrocode}
\SetDefaultHookLabel{cc}
%    \end{macrocode}
%
%
% \subsection{Package Options}
%
% The \lstinline{debug} option triggers the output of additional
% information messages to the shell.
%    \begin{macrocode}
\newif\if@cc@debug \@cc@debugfalse
\DeclareOptionX{debug}{\global\@cc@debugtrue}
%    \end{macrocode}
% The \lstinline{debug-domain} option serves as a filter for log
% messages. It takes a comma separated list of log message categories
% as argument. Only messages whose domain match any item of that list
% are printed. If the option is omitted or its argument empty, all
% messages are printed.
%
% Implies \lstinline{debug}.
%    \begin{macrocode}
\global\let\debug@domain@list\relax
\DeclareOptionX{debug-domain}{%
  \global\@cc@debugtrue
  \if!#1!\else
    \def\do##1{\listadd\debug@domain@list{##1}}%
    \docsvlist{#1}%
  \fi
}%
%    \end{macrocode}
% The \lstinline{prefix} option will be explained below in
% Sect.~\ref{sec:kernel:global-switches}.
%    \begin{macrocode}
\DeclareOptionX{prefix}[]{\gdef\cc@prefix{#1}}%
\ProcessOptionsX
%    \end{macrocode}
%
%
% \section{Exception handlers}
%
% The {\CoCoTeX} kernel provides some macros to unify exception
% handling. There are four levels of output: \lstinline{error},
% \lstinline{warning}, \lstinline{info}, and \lstinline{debug}.
%
% \begin{macro}{\ccPackageError} creates an error message specific to
%   the Framework.
%   \begin{ArgList}
%   \item[1] is the module
%   \item[2] is the type of error
%   \item[3] is the immediate error message
%   \item[4] is the help string
% \end{ArgList}
%    \begin{macrocode}
\def\ccPackageError#1#2#3#4{%
   \GenericError{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      [CoCoTeX #1 #2 Error] #3%
   }{}{#4}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccPackageWarning} is a macro to create warnings
%   specific to the Framework. 
%   \begin{ArgList}
%   \item[1] is the module
%   \item[2] is the type of error
%   \item[3] is the immediate warning message
%   \end{ArgList}
%    \begin{macrocode}
\def\ccPackageWarning#1#2#3{%
   \GenericWarning{%
      (#1)\@spaces\@spaces\@spaces\@spaces
   }{%
      [CoCoTeX #1 \if!#2!\else#2 \fi Warning] #3%
   }%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccPackageInfo}
%   is a macro to create shell output specific to the Framework.
%   \begin{ArgList}
%   \item[1] is the module
%   \item[2] is the type of message
%   \item[3] is the immediate info string
%   \end{ArgList}
%    \begin{macrocode}
\def\ccPackageInfo#1#2#3{%
  \GenericInfo{%
    (#1)\@spaces\@spaces\@spaces\@spaces
  }{%
    [CoCoTeX #1\if!#2!\else\space#2\fi] #3%
  }%
}
%    \end{macrocode}
% \end{macro}
% While the macros defined above are meant to be used in all
% {\CoCoTeX} modules, the following is only for the Kernel.
%
% \begin{macro}{\cc@debug@@message} is a generic debug message that is
%   displayed whenever the debug option is set. Otherwise, it gobbles
%   its argument.
%    \begin{macrocode}
\if@cc@debug
  \def\do#1{\message{^^J==>defining cc@debug@#1@message}\csgdef{cc@debug@#1@message}##1{\typeout{[CoCo #1 Debug]\space##1}}}%
  \dolistloop{\debug@domain@list}%
  \def\cc@debug@@message#1{\typeout{[CoCo Debug]\space#1}}
\else
  \let\cc@debug@@message\@gobble
\fi
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccDebugMsg} prints a domain specific debug message.
%   \begin{ArgList}
%   \item*[1] is the debug domain for filtering
%   \item[2] is the message
%   \end{ArgList}
%   The whole mechanism works by \textit{dynamicly} defining the
%   underlying, domain specific, debug message macros, which all
%   follow the scheme \lstinline{cc@debug@<domain>@message}. If the
%   debug domain is requested via the debug-domains class option, the
%   macros whose domain is listed in this key are defined on
%   runtime. Otherways, the mandatory argument gets gobbled.
%    \begin{macrocode}
\def\ccDebugMsg{\cc@opt@empty\cc@debug@msg}
\def\cc@debug@msg[#1]#2{%
  \expandafter\ifx\csname cc@debug@#1@message\endcsname\relax
    \@gobble{#2}%
  \else
    \csname cc@debug@#1@message\endcsname{#2}%
  \fi
  }
%    \end{macrocode}
% 
% \begin{macro}{\ccKernelDebugMsg} prints a {\CoCoTeX} kernel specific
%   debug message.
%    \begin{macrocode}
\def\ccKernelDebugMsg{\cc@debug@msg[kernel]}
%    \end{macrocode}
% \end{macro}
%
% \section{Global Switches}\label{sec:kernel:global-switches}
%
% \begin{macro}{\ccPrefix} is the prefix that is added to Component
%   macros and (some) Container environments.
%
%   This has mostly historic reasons: back when CoCoTeX was specific
%   to the \textit{xerif} typesetting automaton, all macros produced
%   by the xml converter had a \lstinline{tp} prefix (from
%   \textbf{t}rans\textbf{p}ect, the XML conversion tool in the
%   backend of \textit{xerif}). After CoCoTeX became stand-alone, the
%   tp prefix became obsolete, but the converters running at the time
%   needed to be backward-compatible. Therefore, all xerif-bound
%   CoCoTeX instances still set this macro to ensure user-level macros
%   bear the tp-prefix.
%    \begin{macrocode}
\ifx\ccPrefix\@undefined\edef\ccPrefix{\cc@prefix}\fi
\ccPackageInfo{Kernel}{Info}{The macro prefix is now `\ccPrefix'.}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\if@cc@is@final} is a boolean switch that indicates
%     whether or not a process is final. This is mainly used in the
%     accessibility module where it matters if a macro is actually
%     used to print struff, or if it is just processed.
%    \begin{macrocode}
\newif\if@cc@is@final \@cc@is@finalfalse
\AtBeginDocument{\@cc@is@finaltrue}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccWhenAlly} is a stub that eats its argument. It only
%   does stuff when the \lstinline{coco-accessibility} package is
%   loaded, which we cannot know, yet.
%    \begin{macrocode}
\let\ccWhenAlly\@gobble
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUnlessAlly} is a stub that does nothing.
%    \begin{macrocode}
\let\ccUnlessAlly\@iden
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfAlly} the same, but it takes two arguments, one
%   for the \textit{true} case and a second for the \textit{false}
%   case. We default to the \textit{else} case, so we always gobble
%   the first argument. This will be altered if the
%   \lstinline{coco-accessibility} package is loaded later.
%    \begin{macrocode}
\let\ccIfAlly\@gobble
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\if@cc@modern} is a switch to distinguish older
%     versions of the {\LaTeX} Kernel from newer versions. The pivot
%     date is defined to be 2020/06/01.
%    \begin{macrocode}
\ifx\IfFormatAtLeastTF\@undefined
  \providecommand\IfFormatAtLeastTF{\@ifl@t@r\fmtversion}%
\fi
\IfFormatAtLeastTF{2020/06/01}{}%
  {\ccPackageError{Kernel}{Comatibility}
    {LaTeX kernel too old!}
    {CoCoTeX v0.5.1 and newer needs at least LaTeX kernel version 2020/06/01!}}
%    \end{macrocode}
% \end{macro}
%
% \section{Containers}
%
% Containers are the package's core data structure. They are basicly
% sets of properties that are processed in the same way.
%
% \begin{macro}{\ccDeclareContainer} is the constructor for new
%   Containers.
%   \begin{ArgList}
%   \item[1] is the Container's name
%   \item[2] is its body, which conists of Inheritance
%     instructions, Type and Env declarations.
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@warning@spaces{\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space\space}%
\long\def\ccDeclareContainer#1#2{%
  \ifcsdef{cc@container@#1}
    {\ccPackageWarning{Kernel}{}{Re-declaring Container `#1'^^J%
\cc@warning@spaces All Type settings up to this point will remain!}}
    {\csdef{cc@container@#1}{}}%
  \csdef{cc@cur@cont}{#1}%
%    \end{macrocode}
% We want the declarator macros to be only allowed inside the
% \lstinline{\ccDeclareContainer} macro.
%    \begin{macrocode}
  \begingroup
%    \end{macrocode}
% \begin{macro}{\ccInherit} The inherit mechanism is dynamic, i.e., we
%   can load multiple type declarations from multiple containers at
%   once.
%   \begin{ArgList}
%   \item[1]is a comma-separated list of Types that should be
%     inherited
%   \item[2]is a comma-separated list of Container names which the
%     Types should be inherited from
%   \end{ArgList}
%    \begin{macrocode}
    \def\ccInherit##1##2{\cc@inherit{##1}{##2}{#1}\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccDeclareType}
%   Each Container is defined by the data types it provides. These data
%   types are declared with this macro.
%   \begin{ArgList}
%   \item[1] is the name of the data type
%   \item[2] is code that is specific to this type, usually something like Component or
%     Property declarations, handlers, and so forth
%   \end{ArgList}
%    \begin{macrocode}
    \long\def\ccDeclareType##1##2{\csgappto{cc@type@##1@#1}{##2}\ignorespaces}%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccDeclareEnv} Each container usually is realised as a
%   {\LaTeX} environment. The \lstinline{\ccDeclareEnv} macro is used
%   to set up this environment. Usually, the environment has
%   \textit{the same name as the Container}.
%   \begin{ArgList}
%   \item*[1] overrides the environment's name.  However,
%     keep in mind that the Container's name is not changed by re-naming
%     the corresponding environment.
%   \item[2] is used for the stuff done at the environment's beginning
%   \item[3] is the stuff done at the environment's end
%   \end{ArgList}
%   In the \lstinline{begin} part, the Types declared in the Container
%   declaration's body should be evaluated using the
%   \lstinline{\ccEvalType} macro, see below.
%    \begin{macrocode}
    \def\ccDeclareEnv{\@ifnextchar [{\cc@declare@env}{\cc@declare@env[#1]}}%]
    \def\cc@declare@env[##1]##2##3{%
      \csgdef{\ccPrefix ##1}{\global\let\reserved@cont\cc@cur@cont\def\cc@cur@cont{#1}##2}%
      \csgdef{end\ccPrefix ##1}{##3}\global\let\cc@cur@cont\reserved@cont}%
%    \end{macrocode}
% \end{macro}
% The body of the Container is expanded outside the local group. That
% way the user can define the Container globally using the locally
% defined macros above.
%    \begin{macrocode}
    \def\x{%
      #2%
    }%
  \expandafter\x\endgroup
\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccSetContainer} is used to change the currently
%   active (Sub-)Container.
%   \begin{ArgList}
%   \item[1] is the name of the new active Container
%   \end{ArgList}
%    \begin{macrocode}
\def\ccSetContainer#1{\def\cc@cur@cont{#1}\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccAddToType} add additional content (i.e., the next
%   token) to a Type \InlineArg{1} of a previously declared Container
%   \InlineArg{2}.
%    \begin{macrocode}
\def\ccAddToType#1#2{\csgappto{cc@type@#1@#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccEvalType} calls the declaration list for Data Type
%   \InlineArg{2}. With optional \InlineArg*{1}, the Type's Container
%   name can be overriden locally.
%    \begin{macrocode}
\def\ccEvalType{\cc@opt@curcont\cc@eval@type}
\def\cc@eval@type[#1]#2{%
  \expandafter\ifx\csname cc@type@#2@#1\endcsname\relax
    \ccPackageError{Kernel}{Class}
      {Data Type #2 in Container #1 undefined!}
      {You try to evaluate a data type `#2' from container `#1', but that data type has not been declared.}%
  \else
    \ccKernelDebugMsg{Evaluating cc@type@#2@#1:^^J \csmeaning{cc@type@#2@#1}}%
    \csname cc@type@#2@#1\endcsname
  \fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccCheckParent} checks if a Container \InlineArg{1} is
%   declared so that another Container \InlineArg{2} can inherit.
%    \begin{macrocode}
\def\ccCheckParent#1#2{%
  \expandafter\ifx\csname cc@container@#1\endcsname\relax
    \ccPackageError{Kernel}{Class}
    {Parent Container `#1' undeclared}
    {You tried to make a Container named `#2' inherit from a Container named `#1', but a Container with that name does not exist.\MessageBreak
     Please make sure that parent Containers are declared before their descendents.}%
  \else
    \csgdef{cc@parent@#2}{#1}%
  \fi
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@inherit} is the low-level inherit function.
%   \begin{ArgList}
%   \item[1] is a comma-separated list of things to be inherited
%   \item[2] is the Container-list that should be inherited from
%   \item[3] is the name of the inherting Container
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@inherit#1#2#3{\cc@parse@inherit #1,,\@nil #2,,\@nil #3\@@nil}
%    \end{macrocode}
% \begin{macro}{\cc@parse@inherit} is a low-level function to
%   recursively parse the parameters of the \lstinline{\cc@inherit}
%   macro, above.
%    \begin{macrocode}
\def\cc@parse@inherit #1,#2,\@nil #3,#4,\@nil #5\@@nil{%
  \let\next\relax
  \if!#1!\else
    \if!#3!\else
      \cc@do@inherit{#1}{#3}{#5}%
      \def\@argii{#2}\def\@argiv{#4}%
      \ifx\@argii\@empty
        \ifx\@argiv\@empty\else
          \def\next{\cc@parse@inherit #1,,\@nil #4,\@nil #5\@@nil}%
        \fi
      \else
        \ifx\@argiv\@empty
          \def\next{\cc@parse@inherit #2,\@nil #3,,\@nil #5\@@nil}%
        \else
          \def\next{%
            \cc@parse@inherit #1,,\@nil #4,\@nil #5\@@nil
            \cc@parse@inherit #2,\@nil #3,#4,\@nil #5\@@nil
          }%
        \fi\fi\fi\fi
  \next}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@do@inherit} is the macro that actually causes inheritance.
%   \begin{ArgList}
%   \item[1] is the name of a Type
%   \item[2] is the name of the Container that Type \InlineArg{1} is \textit{inherited} from
%   \item[3] is the name of the Container that \textit{inherits} Type \InlineArg{1}
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@do@inherit#1#2#3{%
  \ccKernelDebugMsg{#3 inherits #1 from #2.}%
  \ccCheckParent{#2}{#3}%
  \expandafter\ifx\csname cc@type@#1@#2\endcsname\relax
    \ccPackageError{Kernel}{Type}{Type `#1' was not declared}{Type `#1' was not declared for Container `#2'.}%
  \else
    \edef\x{\noexpand\csgappto{cc@type@#1@#3}}%
    \expandafter\expandafter\expandafter\x\expandafter\expandafter\expandafter{\csname cc@type@#1@#2\endcsname}%
    \ccKernelDebugMsg{value cc@type@#1@#3:^^J \expandafter\meaning\csname cc@type@#1@#3\endcsname}%
  \fi
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \section{Components}
%
% \subsection{Simple Components}
% ``Simple Components'' are basicly data storages. They are used
% within Containers to obtain data and store them for further
% processing at the end of the Container, or even beyond.
%
% \begin{macro}{\ccDeclareComponent} defines a simple Component macro.
%   The internal macro that is used to store the Component's value is
%   \lstinline{\csname cc@<current Container name>@<#1>\endcsname}.
%   \begin{ArgList}
%   \item*[1] is the Component's identifier. If omitted,
%     \InlineArg{1} is the same as \InlineArg{2}.
%   \item[2] is the Component's name
%   \item[3] is code that is executed \textit{before} assignment of the user's value
%   \item[4] is code that is executed \textit{after} assignment of the user's value
%   \end{ArgList}
%    \begin{macrocode}
\def\ccDeclareComponent{\cc@opt@second\cc@declare@comp}
\def\cc@declare@comp[#1]#2#3#4{%
  \ltx@LocalExpandAfter\global\expandafter\let\csname cc@\cc@cur@cont @#1\endcsname\relax
  \expandafter\long\expandafter\def\csname \ccPrefix#2\endcsname##1{%
    #3\expandafter\long\expandafter\def\csname cc@\cc@cur@cont @#1\endcsname{##1}#4\ignorespaces}%
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccDeclareGlobalComponent} is a shortcut to declare
%   simple, globally available Components with the name \InlineArg{2}
%   and an optional initial value \InlineArg*{1}. They are usually
%   empty.
%    \begin{macrocode}
\def\ccDeclareGlobalComponent{\cc@opt@empty\cc@declare@global@comp}%
\def\cc@declare@global@comp[#1]#2{%
  \ccDeclareComponent{#2}{\expandafter\global}{}%
  \if!#1!\else\csname \ccPrefix #2\endcsname{#1}\fi%
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% Once declared, a component can be set in two ways: The first way is
% to use \lstinline{\ccPrefix<name>} with one argument for its
% value. The second, preferred, way is to use the
% \lstinline{\ccComponent} macro:
% \begin{macro}{\ccComponent} is the preferred way to fill a Component
%   with content.
%   \begin{ArgList}
%   \item[1] is the Component's name
%   \item[2] is the Instance value.
%   \end{ArgList}
%    \begin{macrocode}
\long\protected\def\ccComponent#1#2{%
  \ifx\cc@is@counted\relax
    \ifcsdef{cc@\cc@cur@cont @#1}{}
      {\cc@def@counted@comp{\cc@counted@comp@scheme{#1}}{#1}{}{}}%
    \csgdef{cc@\cc@cur@cont @\cc@counted@comp@scheme{#1}}{#2}%
  \else
    \ifcsdef{cc@\cc@cur@cont @#1}{}{\ccDeclareComponent{#1}{}{}}%
    \csdef{cc@\cc@cur@cont @#1}{#2}%
  \fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccGlobalComponent} is a global variant of
%   \lstinline{\ccComponent}.
%   \begin{ArgList}
%   \item[1] is the Component's name
%   \item[2] is the Instance value.
%   \end{ArgList}
%    \begin{macrocode}
\long\protected\global\def\ccGlobalComponent#1#2{%
  \ifx\cc@is@counted\relax
    \ifcsdef{cc@\cc@cur@cont @#1}{}
      {\cc@def@counted@comp{\cc@counted@comp@scheme{#1}}{#1}{}{}}%
    \csgdef{cc@\cc@cur@cont @\cc@counted@comp@scheme{#1}}{#2}%
  \else
    \ifcsdef{cc@\cc@cur@cont @#1}{}{\ccDeclareGlobalComponent{#1}{}{}}%
    \csgdef{cc@\cc@cur@cont @#1}{#2}%
  \fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccComponentEA} is a variant of
%   \lstinline{\ccComponent} but it expands the Content in
%   \InlineArg{2} once before it is assigned to the Component
%   \InlineArg{1}.
%    \begin{macrocode}
\long\protected\def\ccComponentEA#1#2{%
  \def\x{\ccComponent{#1}}\expandafter\x\expandafter{#2}%
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUseComp} is a high level command to return (or
%   print) the material stored as a Component with the name
%   \InlineArg{1}.
%    \begin{macrocode}
\def\ccUseComp#1{\csname cc@\cc@cur@cont @#1\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccdefFromComp} is a user-level command to store the
%   value of a Component \InlineArg{2} into a CS token \InlineArg{1}.
%    \begin{macrocode}
\def\ccdefFromComp#1#2{\cc@store@comp{e}#1{#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccgdefFromComp} is the global variant of
%   \lstinline{\ccdefFromComp}.
%    \begin{macrocode}
\def\ccgdefFromComp#1#2{\cc@store@comp{x}#1{#2}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\strip@longprefix} is a helper macro to strip the
%   prefix from the \lstinline{\meaning} of a \lstinline{\long} macro.
%    \begin{macrocode}
\def\strip@longprefix#1\long macro:->#2{#2}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@store@comp} is a generalized macro to store a
%   component's unexpanded internal definition in a TeX macro.
%   \begin{ArgList}
%   \item[1] is a scope quantifier (either `e' or `x')
%   \item[2] is a CS token
%   \item[3] is the name of a component
%   \end{ArgList}
%    \begin{macrocode}
\long\def\cc@store@comp#1#2#3{%
  \edef\@tempa{\expandonce{\csname protected@#1def\endcsname}\noexpand#2}%
  \protected@edef\@tempb{\csname cc@\cc@cur@cont @#3\endcsname}%
   \ifx\@tempb\relax
     \let#2\relax
   \else
     \expandafter\@tempa\expandafter{\@tempb}%
  \fi
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUseComponentFrom} is a high level command to return
%   (or print) the material stored as a global Component from the
%   Container \InlineArg{1} with the name \InlineArg{2}.
%    \begin{macrocode}
\def\ccUseComponentFrom#1#2{\csname cc@#1@#2\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccGetComp*} is a user-level command to return the
%   contents stored in a Component of name \InlineArg{1} as a
%   paragraph iff the Component is neither empty nor
%   \lstinline{\relax}. If Accessibility features are activated, the
%   returned content of the Component is autmatically tagged with a
%   \lstinline{Para} tag.
%
%   The starred version of \lstinline{\ccGetComp} supresses automated
%   tagging for that Component when the accessibility features are
%   active.
%    \begin{macrocode}
\def\ccGetComp{\@ifstar\cc@sget@comp\cc@get@comp}
\def\cc@get@comp#1{\ccWhenComp{#1}{%
    \ccWhenAlly{\ccaStructStart{Para}}%
    \ccUseComp{#1}%
    \ccWhenAlly{\ccaStructEnd{Para}}%
    \par}}
\def\cc@sget@comp#1{\ccWhenComp{#1}{\ccUseComp{#1}\par}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfComp} is a high level macro that executes
%   \InlineArg{2} if the Component macro \InlineArg{1} is used in a
%   Container (empty or non-empty), and \InlineArg{3} if not.
%    \begin{macrocode}
\long\def\ccIfComp#1#2#3{\expandafter\ifx\csname cc@\cc@cur@cont @#1\endcsname\relax#3\else#2\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccWhenComp} is a high level variant of
%   \lstinline{\ccIfComp} that omits the \lstinline{else}-branch. 
%   \begin{ArgList}
%   \item[1] is the name of the Component
%   \item[2] is code that is expanded when the Component
%     \InlineArg{1} is used in a container (empty or non-empty)
%   \end{ArgList}
%    \begin{macrocode}
\long\def\ccWhenComp#1#2{\expandafter\ifx\csname cc@\cc@cur@cont @#1\endcsname\relax\else#2\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUnlessComp} is a high level variant of
%   \lstinline{\ccIfComp} that omits the \lstinline{then}-branch. 
%   \begin{ArgList}
%   \item[1] is the name of the Component
%   \item[2] is the code that is expanded when a Container
%     \InlineArg{1} is \textit{not} used in a Container (neither empty
%     nor non-empty)
%   \end{ArgList}
%    \begin{macrocode}
\long\def\ccUnlessComp#1#2{\expandafter\ifx\csname cc@\cc@cur@cont @#1\endcsname\relax#2\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfCompFrom} is the global variant of
%   \lstinline{\ccIfComp}. 
%   \begin{ArgList}
%   \item[1] is the name of the Container
%   \item[2] is the name of the Component
%   \item[3] is the \texttt{then}-branch
%   \item[4] is the \texttt{else}-branch
%   \end{ArgList}
%    \begin{macrocode}
\long\def\ccIfCompFrom#1#2#3#4{\expandafter\ifx\csname cc@#1@#2\endcsname\relax#4\else#3\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@long@empty} is a helper macro used as comparator
%   when checking whether a \lstinline{\long} macro is empty or not.
%    \begin{macrocode}
\long\def\cc@long@empty{}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfCompEmpty} is a high level macro that executes
%   \InlineArg{2} if the Component macro \InlineArg{1} is empty (or
%   \lstinline|{}|) within its Container, and \InlineArg{3} if it is
%   either not existant or non-empty.
%    \begin{macrocode}
\long\def\ccIfCompEmpty#1#2#3{\expandafter\ifx\csname cc@\cc@cur@cont @#1\endcsname\cc@long@empty#2\else#3\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfCompFromEmpty} is a global variant of
%   \lstinline{\ccIfCompEmpty}. 
%   \begin{ArgList}
%   \item[1] is the name of the Container
%   \item[2] is the name of the Component
%   \item[3] is the \texttt{then}-branch
%   \item[4] is the \texttt{else}-branch
%   \end{ArgList}
%    \begin{macrocode}
\long\def\ccIfCompFromEmpty#1#2#3#4{\expandafter\ifx\csname cc@#1@#2\endcsname\cc@long@empty#3\else#4\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@check@empty} handles the distinction between empty
%   and un-used components: First, check if \lstinline{#4#3} is set
%   (i.\,e., anything but \lstinline{\relax}). If it is set, check if
%   it is empty. If empty, set \lstinline{#4#3} to \lstinline{\relax},
%   meaning further occurences of \lstinline|\ccIfComp{#4#3}| will
%   execute the \lstinline{else} branch. If \lstinline{#4#3} is
%   non-empty, do nothing.
%
%   If \lstinline{#4#3} is already \lstinline{\relax}, check if the
%   fallback \lstinline{#1#3} is set. If so, make \lstinline{#4#3} an
%   alias of \lstinline{#1#3}. If not, do nothing.
%   \begin{ArgList}
%   \item*[1] is the prefix of the fallback component
%   \item[2] is the Container name
%   \item[3] is the name of the Component
%   \item[4] is the Override's prefix
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@check@empty{\cc@opt@empty\@cc@check@empty}%]
\def\@cc@check@empty[#1]#2#3#4{%
   \ccIfComp{#4#3}
     {\ccIfCompEmpty{#4#3}
       {\expandafter\global\expandafter\let\csname cc@#2@#4#3\endcsname\relax}
       {}}
     {\ccIfComp{#1#3}
       {\expandafter\expandafter\expandafter\let\expandafter\csname cc@#2@#4#3\expandafter\endcsname\csname cc@#2@#1#3\endcsname}
       {}}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Counted Components}
%
% Counted Components are Components that may occur in the same parent
% Container multiple times. They may be multiple instances of
% single-macro Components, or recurring collections of multiple
% Components, called \textbf{Component Groups}.
%
% \subsubsection{Component Groups}\label{sec:kernel:compgroups}
% \begin{macro}{\ccDeclareComponentGroup} is a user-level macro to
%   declare a new Component Group with the name \InlineArg{1} and the
%   body \InlineArg{2}.
%    \begin{macrocode}
\def\ccDeclareComponentGroup#1#2{%
  \csnumgdef{cc#1Cnt}{\z@}%
  \long\csdef{\ccPrefix#1}{\cc@opt@empty{\csname cc@group@#1\endcsname}}%
  \long\csdef{cc@group@#1}[##1]{%
    \def\cc@cnt@grp{cc#1}%
    \csxdef{cc#1Cnt}{\expandafter\the\expandafter\numexpr\csname cc#1Cnt\endcsname+\@ne\relax}%
    \if!##1!\else\long\csgdef{cc@\cc@cur@cont @#1-\csname cc#1Cnt\endcsname @attrs}{##1}\fi
    #2%
    \csname @#1@hook\endcsname
    \ignorespaces
  }%
  \csdef{end\ccPrefix#1}{{\ccToggleCountedConditionals\csuse{cc@compose@group@#1}}\aftergroup\ignorespaces}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccDeclareGroupHandler} is used to declare a new group
%   handler. A Group Handler is a hook for code \InlineArg{2} that is
%   expanded at the end of a Component Group \InlineArg{1}'s
%   environment. It is mostly used to process Components within a
%   Group instance and store the result in their own components. For
%   instance, a Group Handler can be used to combine a First Name and
%   a Surname to a combined Component ``FullName''.
%    \begin{macrocode}
\def\ccDeclareGroupHandler#1#2{%
  \ifcsdef{cc@group@#1}
    {\ifcsdef{cc@compose@group@#1}
      {\csgappto{cc@compose@group@#1}{#2}}
      {\csgdef{cc@compose@group@#1}{#2}}}
    {\ccPackageError{Kernel}{Type}{Component Group `#1' unknown!}{You tried to declare a Group Handler for a Component Group that has not been declared, yet! Use \string\ccDeclareComponentGroup{#1}{} to declare the Component Group first.}}%
\ignorespaces}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cc@cnt@grp} is a designated group name. Counted
%   Components of the same group use the same counter.
%    \begin{macrocode}
\let\cc@cnt@grp\@empty
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUseCompByIndex} picks a Component with name
%   \InlineArg{3} and index \InlineArg{2} from a group \InlineArg{1}.
%    \begin{macrocode}
\def\ccUseCompByIndex#1#2#3{\csname cc@\cc@cur@cont @#1-#3-#2\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUsePropFrom} picks a Counted Component with the
%   index \InlineArg{2} from a Group \InlineArg{1} and renders it
%   using Property \InlineArg{3}.
%    \begin{macrocode}
\def\ccUsePropFrom#1#2#3{%
  \begingroup
    \@tempcnta\numexpr#2\relax
    \letcs\ccTotalCount{cc#1Cnt}%
    \def\cc@cnt@grp{cc#1}%
    \ccToggleCountedConditionals
    \csnumdef{cc#1Cnt}{\the\@tempcnta}%
    \ccCurCount=\the\@tempcnta\relax%
    \csname cc@\cc@cur@cont @#3\endcsname%
  \endgroup}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Iterating over Component Groups}
%
% The following two macros iterate over all instances of a Component
% Group \InlineArg{1} in the current Container and applies for each
% instance the Property \InlineArg{2}. The result is appended to the
% the Collector Component \InlineArg{3}, if and only if that Component
% is not yet set for the current Container at the time of the first
% iteration.
%
% While the first macro only writes the Property \textit{definition}
% into the Collector Component, the second fully expands the macros inside the
% Property and stores the result in Component \#3.
%
% Use the former to print and the latter to further process the
% respective results.
% \begin{macro}{\ccCurCount} stores the number of the current instance
%   of a Counted Component. Use this in the declarations of Properties
%   that are expanded within the Component Group.
%    \begin{macrocode}
\newcount\ccCurCount
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@assign@res} assignes the result of the Component
%   collection to a~control sequence with the name \InlineArg{1} and
%   resets the temporary storage.
%    \begin{macrocode}
\def\cc@assign@res#1{%
  \ifx\cc@iterate@res\relax
    \cslet{#1}\relax
  \else
    \expandafter\csname #1\expandafter\endcsname\expandafter{\cc@iterate@res}%
  \fi
  \global\let\cc@iterate@res\relax
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfComponentOverride} is a switch to apply either
%   \InlineArg{2}, if the Collection Component \InlineArg{1} has been
%   set manually within a container; or \InlineArg{3}, if it has been
%   generated from Counted Components.
%    \begin{macrocode}
\def\ccIfComponentOverride#1#2#3{\expandafter\ifx\csname cc@used@#1@override\endcsname\@empty#2\else#3\fi}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccComposeCollection} is used to create an unexpanded
%   Collection Component \InlineArg{3} from all instances of Component
%   Group \InlineArg{1} using the instructions given by property
%   \InlineArg{2}.
%    \begin{macrocode}
\def\ccComposeCollection#1#2#3{%
  \ccIfComp{#3}{\cslet{cc@used@#3@override}\@empty}{%
    \ifcsdef{cc#1Cnt}{%
      \expandafter\ifnum\csname cc#1Cnt\endcsname > \z@\relax
        \edef\cc@iterate@res{%
          \noexpand\bgroup
            \noexpand\def\noexpand\ccTotalCount{\csname cc#1Cnt\endcsname}%
            \noexpand\ccToggleCountedConditionals
            \noexpand\def\noexpand\cc@cnt@grp{cc#1}}%
          \expandafter\@tempcntb=\csname cc#1Cnt\endcsname\relax
          \cc@iterate{\@tempcnta}{\@ne}{\@tempcntb}{%
            \edef\@tempb{%
              %% top-level counter for user interaction
              \noexpand\ccCurCount=\the\@tempcnta
              %% evaluating group attributes
              \ifcsdef{cc@\cc@cur@cont @#1-\the\@tempcnta @attrs}{\noexpand\ccParseAttributes{#1-\the\@tempcnta}{\csname cc@\cc@cur@cont @#1-\the\@tempcnta @attrs\endcsname}}{}
              %% internal counter for macro grabbing
              \noexpand\csnumdef{cc#1Cnt}{\ccCurCount}%
              \noexpand\ccUseProperty{#2}}%
            \expandafter\expandafter\expandafter\def
            \expandafter\expandafter\expandafter\cc@iterate@res
            \expandafter\expandafter\expandafter{\expandafter\cc@iterate@res\@tempb}%
          }%
          \expandafter\def\expandafter\cc@iterate@res\expandafter{\cc@iterate@res\egroup}%
          \cc@assign@res{\ccPrefix#3}%
      \fi
    }{}}%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccApplyCollection}
%   is an alternative version of \lstinline{\ccComposeCollection} and
%   fully expands the result of the application of Property
%   \InlineArg{2} before it is stored inside the Component
%   \InlineArg{3}.
%    \begin{macrocode}
\def\ccApplyCollection#1#2#3{%
  \ccIfComp{#3}{\cslet{cc@used@#3@override}\@empty}
    {\cc@apply@collection{#1}{#2}%
     \cc@assign@res{\ccPrefix#3}%
   }%
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@apply@collection} is the low-level macro used to
%   fully expand a Component Group \InlineArg{1} into its Collection
%   Component using Property \InlineArg{2}.
%    \begin{macrocode}
\def\cc@apply@collection#1#2{%
  \begingroup
    \global\let\cc@iterate@res\relax
    \letcs\ccTotalCount{cc#1Cnt}%
    \cc@iterate{\@tempcnta}{\@ne}{\ccTotalCount}{%
      \bgroup
        \ccToggleCountedConditionals
        \def\cc@cnt@grp{cc#1}%
        \csnumdef{cc#1Cnt}{\the\@tempcnta}%
        \ifcsdef{cc@\cc@cur@cont @#1-\the\@tempcnta @attrs}{\ccParseAttributes{#1-\the\@tempcnta}{\csname cc@\cc@cur@cont @#1-\the\@tempcnta @attrs\endcsname}}{}
        \ccCurCount=\the\@tempcnta
        \protected@xdef\@tempb{\csname cc@\cc@cur@cont @#2\endcsname}%
        \@temptokena \expandafter{\@tempb}%
        \def\@tempc{\csgappto{cc@iterate@res}}%
        \expandafter\@tempc\expandafter{\@tempb}%
      \egroup
    }%
  \endgroup
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@comp@def} is used to pass a Counted Component into
%   a TeX macro.
%   \begin{ArgList}
%   \item[1] is a prefix to the def command, e.g., \lstinline{\global}
%     or \lstinline{\protected}
%   \item[2] is a CS token
%   \item[3] is the Name of the Counted Component
%   \item[4] is the Property that should be applied to all Members of
%     the Counted Component
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@comp@def{\cc@opt@empty\@cc@comp@def}
\def\@cc@comp@def[#1]#2#3#4{%
  \cc@apply@collection{#3}{#4}%
  \ifx\cc@iterate@res\relax
    #1\let#2\relax%
  \else
    \def\@tempa{#1\def#2}%
    \cc@assign@res{@tempa}%
  \fi
}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccdefFromCountedComp} is the user-level command for
%   \textit{local} \lstinline{\cc@comp@def}.
%    \begin{macrocode}
\def\ccdefFromCountedComp{\cc@comp@def}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccgdefFromCountedComp} is the user-level command for
%   \textit{global} \lstinline{\cc@comp@def}.
%    \begin{macrocode}
\def\ccgdefFromCountedComp{\cc@comp@def[\global]}
\def\ccpgdefFromCountedComp#1{\expandafter\ccgdefFromCountedComp\csname \ccPrefix #1\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Declaring Counted Component}
%
% \begin{macro}{\cc@counted@comp@scheme} gives the scheme how counted
%   components are defined internally.
%   \begin{ArgList}
%   \item[1] the name of the Counted Component.
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@counted@comp@scheme#1{\cc@cnt@grp-#1-\csname \cc@cnt@grp Cnt\endcsname}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccDeclareCountedComponent}
%   is a user-level macro to create a new Counted Component.
%   \begin{ArgList}
%   \item[1] is the user-level name of the Component
%   \end{ArgList}
%    \begin{macrocode}
\def\ccDeclareCountedComponent#1{%
  \cc@def@counted@comp
    {\cc@counted@comp@scheme{#1}}
    {#1}
    {}
    {\expandafter\global}%
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@def@counted@comp} is used to declare Counted Components.
%   \begin{ArgList}
%   \item[1] is the internal name of the Component which is composed
%     out of the group name, the value of the group counter and the
%     user-level macro name \InlineArg{2}
%   \item[2] is the name of the Counted Component
%   \item[3] is some custom code passed to the second argument of
%     \lstinline{\ccDeclareComponent}
%   \item[4] is a modifier to the internal macro definition.
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@def@counted@comp#1#2#3#4{%
  \ccDeclareComponent[#1]{#2}
    {\bgroup#3\expandafter\global}
    {\def\@tempa{{@cc@reset@components@\cc@cur@cont}}%
     \edef\@tempb{\noexpand\csgundef{cc@\noexpand\cc@cur@cont @#1}}%
     \expandafter\expandafter\expandafter\csgappto\expandafter\@tempa\expandafter{\@tempb}%
     \egroup}%
   \ignorespaces
   #4\expandafter\long\expandafter\def\csname cc@\cc@cur@cont @#2\endcsname{\csname cc@\cc@cur@cont @#1\endcsname}%
   \ignorespaces}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Resetting Counted Component}
%
% \begin{macro}{\cc@reset@components}
%   is used to reset Counted Components to prevent later Containers of
%   a given type to feed the components from the previous Container of
%   the same type. Usually, this is prevented by keeping Component
%   definitions strictly local.
%
%   I some cases, however, Components may be declared globally, i.e.,
%   they may be re-used after the Container is ended. In this
%   so-called Asynchronuous Processing of Components, the reset should
%   be done at the very beginning of the next instance of the
%   container type to prevent bleeding of one container's components
%   into the next one, specifically if a container occurs more than
%   once in the same document.
%   \begin{ArgList}
%   \item[1] is the name of the Component Group
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@reset@components#1{%
  \csname @cc@reset@components@#1\endcsname
  \global\cslet{@cc@reset@components@#1}\relax%
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Toggling Conditionals for Counted Components}
%
%
% \begin{macro}{\ccToggleCountedConditionals}
%   In order to process Counted Components, we need to re-define the
%   Conditionals in a way such that the Component is expanded twice
%   before the comparison takes place to correctly resolve the
%   Component counter.
%
%   \textbf{Warning!} Use this macro only within local groups!
%    \begin{macrocode}
\long\def\ccToggleCountedConditionals{%
  \let\cc@is@counted\relax
%    \end{macrocode}
% This re-definitions of \lstinline{\ccIfComp} cannot use
% \lstinline{etoolbox}'s \lstinline{\cs...} macros since the
% conditional can be embedded inside itself. If an inner csname is
% undefined, the condition for the outer one would be reset
% before it can be expanded by \lstinline{\ifx}.
%    \begin{macrocode}
  \long\def\ccIfComp##1{%
    \expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\ifx\csname cc@\cc@cur@cont @##1\endcsname\relax\expandafter\@secondoftwo\else\expandafter\@firstoftwo\fi%
  }%
  \long\def\ccWhenComp##1{%
    \expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\ifx\csname cc@\cc@cur@cont @##1\endcsname\relax\expandafter\@gobble\else\expandafter\@firstofone\fi%
  }%
  \long\def\ccUnlessComp##1{%
    \expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\expandafter\ifx\csname cc@\cc@cur@cont @##1\endcsname\relax\expandafter\@firstofone\else\expandafter\@gobble\fi%
  }%
  \long\def\ccIfCompEmpty##1{%
    \expandafter\expandafter\expandafter\ifx\csname cc@\cc@cur@cont @##1\endcsname\cc@long@empty\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi}%
  \ccToggleCountedConditionalsHook% legacy
}
%    \end{macrocode}
% \end{macro}
%
% \section{Hooks}
%
% \TODO{Use latex3's hook facility instead. Look at latexreleases.sty to ensure forward compatibility}
%
% Hooks are used to patch code into different parts of a Container's
% processing chain.
% \begin{macro}{\ccDeclareHook} registers a new hook.  Hooks always
%   default to an empty string.
%   \begin{ArgList}
%   \item*[1] is the Container for which the Hook is
%     declared. If omitted, this defaults to the currently active
%     Container (\lstinline{\cc@cur@cont})
%   \item[2] is the Hook's user-level name
%   \end{ArgList}
%    \begin{macrocode}
\def\ccDeclareHook{\cc@opt@curcont\cc@declare@hook}
\def\cc@declare@hook[#1]#2{\expandafter\global\expandafter\let\csname cc@hook@#1@#2\endcsname\@empty}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccAddToHook} adds new material to a Hook. If the hook
%   has not yet been declared, a \lstinline{\ccDeclareHook} for that
%   hook is applied first. In that case, use the optional
%   \InlineArg*{1} to specify the Container name that hook is intended
%   for. If it is omitted, the current Container is
%   used. \InlineArg{2} is the name of the hook the material in
%   \InlineArg{3} is to be appended to.
%    \begin{macrocode}
\def\ccAddToHook{\cc@opt@curcont\cc@add@to@hook}
\def\cc@add@to@hook[#1]#2#3{%
  \expandafter\ifx\csname cc@hook@#1@#2\endcsname\relax
    \ccDeclareHook[#1]{#2}%
  \fi
  \csgappto{cc@hook@#1@#2}{#3}%
\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUseHook} expands the current state of the hook with
%   the name \InlineArg{2} from Container \InlineArg*{1} (current
%   Container if omitted).
%    \begin{macrocode}
\def\ccUseHook{\cc@opt@curcont\cc@use@hook}
\def\cc@use@hook[#1]#2{\csuse{cc@hook@#1@#2}\ignorespaces}
%    \end{macrocode}
% \end{macro}
%
% \section{Properties}\label{sec:kernel:props}
% \subsection{Setting Properties}\label{sec:kernel:prop:set}
%
% \begin{macro}{\ccSetProperty}
%   is a user-level macro that provides the Property--Value interface
%   for Containers.
%   \begin{ArgList}
%   \item[1] is the name of the Property
%   \item[2] is the Value assigned to that Property.
%   \end{ArgList}
%    \begin{macrocode}
\long\def\ccSetProperty#1#2{\long\csdef{cc@\cc@cur@cont @#1}{#2}\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccAppToProp} can be used add material to the
%   \textit{end} of an existing Property vaue.
%   \begin{ArgList}
%   \item[1] is the name of the Property
%   \item[2] is the material to be added to previous value of
%     that Property
%   \end{ArgList}
%    \begin{macrocode}
\def\ccAppToProp#1#2{%
  \long\csappto{cc@\cc@cur@cont @#1}{#2}%
\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccPreToProp} can be used add material to the
%   \textit{beginning} of an existing Property.
%   \begin{ArgList}
%   \item[1] is the name of the Property
%   \item[2] is the material to be inserted before the previous
%     value of that Property
%   \end{ArgList}
%    \begin{macrocode}
\def\ccPreToProp#1#2{%
  \long\cspreto{cc@\cc@cur@cont @#1}{#2}%
\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccPropertyLet} can be used to create an alias
%   Property \InlineArg{1} of a given Property \InlineArg{2}. Is is
%   equivalent to
%   \lstinline|\ccSetProperty{\#1}{\ccUseProperty{\#2}}|.
%    \begin{macrocode}
\long\def\ccPropertyLet#1#2{\long\csedef{cc@\cc@cur@cont @#1}{\expandonce{\csname cc@\cc@cur@cont @#2\endcsname}}\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccPropertyLetX} creates a Property \InlineArg{1} with
%   the fully expanded value of another Property \InlineArg{2}. Is is
%   equivalent to
%   \lstinline|\ccSetPropertyX{\#1}{\ccUseProperty{\#2}}|.
%    \begin{macrocode}
\long\def\ccPropertyLetX#1#2{\long\csedef{cc@\cc@cur@cont @#1}{\csname cc@\cc@cur@cont @#2\endcsname}\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccSetPropertyVal}
%   is a variant of \lstinline{\ccSetProperty} that expands the value
%   \InlineArg{2} \textit{once} before assigning it to the Property
%   macro with the name \InlineArg{1}. This can be used to assign the
%   current value of a variable macro, dimension, counter or length to
%   a Property.
%    \begin{macrocode}
\long\def\ccSetPropertyVal#1#2{\def\@tempa{\ccSetProperty{#1}}\expandafter\@tempa\expandafter{#2}\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccSetPropertyX}
%   is another variant of \lstinline{\ccSetProperty}, but it
%   \textit{fully expands} the value (using \lstinline{\edef}) defined
%   in \InlineArg{2} before the Property is stored in the Property
%   macro named \InlineArg{1}. Use this if you need to use
%   conditionals to determine the actual values of Properties that
%   otherwise expect fixed named or dimensional values.
%    \begin{macrocode}
\long\def\ccSetPropertyX#1#2{\long\csedef{cc@\cc@cur@cont @#1}{#2}\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccAddToProperties} adds the material in \InlineArg{2}
%   to a Container of name \InlineArg{1}'s \lstinline{Properties}
%   List.
%    \begin{macrocode}
\long\def\ccAddToProperties#1#2{\ccAddToType{Properties}{#1}{#2}\ignorespaces}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Using Properties}\label{sec:kernel:prop:use}
%
% \begin{macro}{\ccUseProperty} is a user-level command to directly
%   access a previously set Property with the name \InlineArg{1}.
%    \begin{macrocode}
\def\ccUseProperty#1{\csuse{cc@\cc@cur@cont @#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@store@prop} stores the result of the application
%   of property \InlineArg{3} in the control sequence
%   \InlineArg{2}. The optional \InlineArg*{1} can hold a definition
%   modifier like \lstinline{\global} or \lstinline{\long}.
%    \begin{macrocode}
\def\cc@store@prop{\cc@opt@empty\@cc@store@prop}%
\long\def\@cc@store@prop[#1]#2#3{%
  \protected@edef\@tempa{\ccUseProperty{#3}}%
  #1\expandafter\def\expandafter#2\expandafter{\@tempa}%
\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccdefFromProperty} expands an (implicit) Property
%   \InlineArg{2} and stores the result in (implicit) control sequence
%   \InlineArg{1}.
%    \begin{macrocode}
\def\ccdefFromProperty{\cc@store@prop}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccgdefFromProperty} is the \lstinline{\global} variant
%   of \lstinline{\ccdefFromProperty}.
%    \begin{macrocode}
\def\ccgdefFromProperty{\cc@store@prop[\global]}
\def\ccpgdefFromProperty#1{\expandafter\ccgdefFromProperty\csname \ccPrefix #1\endcsname}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ccUsePropertyEnv}
%   is a user-level command to access a previously set Property and
%   make it an environment accessible to Property specific processing
%   instrunctions (see below).
%    \begin{macrocode}
\def\ccUsePropertyEnv#1{\cslet{cc@#1@active}{\relax}\csuse{cc@\cc@cur@cont @#1}\csundef{cc@#1@active}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfStrEqual} is a variant of etoolbox's
%   \lstinline{\ifstrequal} that first fully expands both arguments
%     \InlineArg{1} and \InlineArg{2} (using \lstinline{\edef})
%     before comparing them.
%    \begin{macrocode}
\def\ccIfStrEqual#1#2{%
  \edef\@argi{#1}\edef\@argii{#2}%
  \expandafter\expandafter\expandafter\ifstrequal
    \expandafter\expandafter\expandafter{\expandafter\@argi\expandafter}%
      \expandafter{\@argii}}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Local Property Overrides}
%
% \begin{macro}{\cc@set@property@local} is a low-level macro to
%   locally manipulate Properties. 
%   \begin{ArgList}
%   \item[1] is the CS token representing a method to alter the
%     property (\lstinline{\ccSetProperty}, \lstinline{\ccAppToProp},
%     or \lstinline{\ccPreToProp})
%   \item[2] is the name of the Property to be altered
%   \item[3] is the new (or added) Value
%   \end{ArgList}
%    \begin{macrocode}
\def\cc@set@property@locally#1#2#3{%
  \let\@cc@cur@cont\cc@cur@cont
  \ifdefstring\@cc@cur@cont{Heading}{\let\@cc@cur@cont\ccCurSecName}{}%
  \csappto{cc@type@Properties@\@cc@cur@cont}{#1{#2}{#3}}%
}
%    \end{macrocode}
% \end{macro}
% The User level macros are Prefix sensitive. They exist in three
% flavours depending on whether the global Value of a Property should
% be kept or be replaced.
%
% They all take two arguments:
% \begin{ArgList}
% \item[1] is the name of the Property
% \item[2] is the value to be set, appended, or prepended to that
%   Property, respectively.
% \end{ArgList}
% \begin{macro}{\ccSetPropLocal} sets a Property \InlineArg{1} to a
%   new value \InlineArg{2}.
%    \begin{macrocode}
\def\ccSetPropLocal{\cc@set@property@locally\ccSetProperty}
\cslet{\ccPrefix SetPropLocal}\ccSetPropLocal%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccAppPropLocal} appends the value \InlineArg{2} to
%   the \textit{end} of an existing Property \InlineArg{1}.
%    \begin{macrocode}
\def\ccAppPropLocal{\cc@set@property@locally\ccAppToProp}
\cslet{\ccPrefix AppPropLocal}\ccAppPropLocal%
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccPrePropLocal} appends the value \InlineArg{2} to
%   the \textit{beginning} of an existing Property \InlineArg{1}.
%    \begin{macrocode}
\def\ccPrePropLocal{\cc@set@property@locally\ccPreToProp}
\cslet{\ccPrefix PrePropLocal}\ccPrePropLocal%
%    \end{macrocode}
% \end{macro}
%
% \subsection{Processing Instructions}\label{sect:ccPI}
%
% In general, processing instructions are commands that are only
% visible to a specific process and ignored by others. In
% \CoCoTeX, Processing Instructions (PIs) are
% commands placed inside a Component that should only take effect when
% that Component is processed through a specific Property.
%
% \begin{macro}{\ccPI} is a Processing Instruction that executes
%   \InlineArg{2} when a Property with the name \InlineArg{1} is
%   currently processed with the \lstinline{\ccUsePropertyEnv} macro.
%    \begin{macrocode}
\DeclareRobustCommand\ccPI[2]{\ifcsdef{cc@#1@active}{#2}{}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Property Conditionals}\label{sec:kernel:prop:cond}
%
% \begin{macro}{\ccIfProp}
%   checks if a Property with the name \InlineArg{1} is defined and
%   non-empty. If so, do \InlineArg{2}, otherwise do \InlineArg{3}.
%    \begin{macrocode}
\long\def\ccIfProp#1#2#3{%
  \expandafter\ifx\csname cc@\cc@cur@cont @#1\endcsname\relax#3\else
    \expandafter\ifx\csname cc@\cc@cur@cont @#1\endcsname\cc@long@empty #3\else#2\fi
  \fi
\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfPropVal}
%   checks if a Property \InlineArg{1} expands to \InlineArg{2}.  If
%   so, do \InlineArg{3}, otherwise do \InlineArg{4}.
%
%   \textbf{Warning}: Do not use this conditional in Properties that
%   are used in \lstinline{\ccApplyCollection}!
%    \begin{macrocode}
\long\def\ccIfPropVal#1#2#3#4{\long\def\@tempa{#2}%
  \expandafter\ifx\csname cc@\cc@cur@cont @#1\endcsname\@tempa\relax#3\else#4\fi\ignorespaces}
%    \end{macrocode}
% \end{macro}
%
%
% \section{Helper macros}
%
% \subsection{Handling of Optional Arguments}
%
% Two simple internal macros to ease up the handling of optional
% arguments.
% \begin{macro}{\cc@opt@curcont} overrides stores the currently active
%   Container name as future \lstinline{#1}, unless the control
%   sequence \InlineArg{1} is called with an optional argument. In
%   this case, the future \lstinline{#1} is the value of that optional
%   argument.
%    \begin{macrocode}
\long\def\cc@opt@curcont#1{\@ifnextchar[{#1}{#1[\cc@cur@cont]}}%]
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@opt@empty} passes an empty string as future
%   \lstinline{#1} if the optional argument is missing.
%    \begin{macrocode}
\long\def\cc@opt@empty#1{\@ifnextchar[{#1}{#1[]}}%]
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cc@opt@second} passes the first \textit{mandatory}
%   argument as value to the \lstinline{optional} argument if the
%   latter is missing.
%    \begin{macrocode}
\let\cc@opt@second\@dblarg
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Iterators}
%
% \begin{macro}{\cc@iterate} traverses in \InlineArg*{1}-th steps
%   (defaults to $+1$) through counter \InlineArg{2}, starting at
%   number \InlineArg{3} until and including number \InlineArg{4} and
%   does \InlineArg{5} at every iteration (from
%   \lstinline{forloop.sty}, \textbf{Be aware} that incrementation of
%   counter \InlineArg{2} takes place after \InlineArg{5} is called!):
%    \begin{macrocode}
\long\def\cc@iterate{\@ifnextchar[{\@cc@iterate}{\@cc@iterate[\@ne]}}%]
\long\def\@cc@iterate[#1]#2#3#4#5{%
  #2=#3\relax%
  \expandafter\ifnum#2>#4\relax%
  \else
    #5%
    \advance#2 by #1\relax
    \cc@iterate[#1]{#2}{\the#2}{#4}{#5}%
  \fi}%
%    \end{macrocode}
% \end{macro}
%
% \subsection{Attributes}
%
% Many macros and environments deal with optional arguments that are
% used to alter the behaviour of that macro or environment. The
% combination of a parameter and its set of possible values are calles
% \textbf{Attributes}. In this section, we define the parsers for
% those paramters.
%
% In order to catch the \lstinline{babel} package's messing with the
% quote symbol, we make sure it has the correct cat-code.
%    \begin{macrocode}
\begingroup
\catcode`"=12
%    \end{macrocode}
% \begin{macro}{\ccParseAttributes} High level wrapper for the
%   attribute parser.
%   \begin{ArgList}
%   \item[1] is the domain of the attribute
%   \item[2] is the raw attribute list
%   \end{ArgList}
%    \begin{macrocode}
\gdef\ccParseAttributes#1#2{%
  \if!#1!\else
    \if!#2!\else
      \def\cc@cur@domain{#1}%
      \cc@parse@attributes #2,,\@nil
    \fi\fi}
%    \end{macrocode}
% \end{macro}
% The actual, recursively applying, parser comes in two parts:
% \begin{macro}{\cc@parse@attributes} parses the single attributes in
%   an optional argument,
%    \begin{macrocode}
\gdef\cc@parse@attributes #1,#2,\@nil{%
  \if!#1!\else
    \cc@parse@kv#1==\@nil
    \if!#2!\else
      \cc@parse@attributes#2,\@nil
    \fi\fi}
%    \end{macrocode}
% \end{macro}
% and
% \begin{macro}{\cc@parse@kv} distinguishes between the attribute name
%   and its value(s).
%    \begin{macrocode}
\gdef\cc@parse@kv#1=#2=#3\@nil{%
  \edef\@argii{#2}%
  \ifx\@argii\@empty
    \expandafter\let\csname cc@\cc@cur@domain @attr@#1\endcsname\@empty%
  \else
    \ifx #2 =\else
      \expandafter\def\csname cc@\cc@cur@domain @attr@#1\endcsname{#2}%
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cc@parse@csv} takes a fallback macro \InlineArg{1}
%   and feeds it as argument to each item of the comma-separated list
%   in the control sequence \InlineArg{2}. The macro \InlineArg{1} is
%   stored internally as \lstinline{\cc@parser@callback}.
%    \begin{macrocode}
\gdef\cc@parse@csv#1#2{%
  \if!#1!\else
    \let\cc@parser@callback#1%
    \edef\cc@tempa{\csname #2\endcsname}%
    \ifx\cc@tempa\@empty\else
      \expandafter\cc@@parse@csv\cc@tempa,,\@nil
    \fi
  \fi}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cc@@parse@csv} applies
%   \lstinline{\cc@parser@callback} to the first item of a
%   comma-separated pair and feeds the second item to itself.
%    \begin{macrocode}
\gdef\cc@@parse@csv #1,#2,\@nil{%
  \if!#1!\else
    \cc@parser@callback{#1}%
  \fi
  \if!#2!\else
    \cc@@parse@csv#2,\@nil
  \fi
  \ignorespaces}
\endgroup
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccEvalAttributes} is a special Type Evaluator for
%   Containers that define their Instance's attributes as Data
%   Type. The Type then contains a list of
%   \lstinline{\ccDeclareAttributeHandler} statements for each of the
%   allowed attributes.
%   \begin{ArgList}
%   \item*[1] is the Attribtue Domain (defaults to the current Container name)
%   \item[2] is the Container Instance's raw Attribute list.
%   \end{ArgList}
%    \begin{macrocode}
\def\ccEvalAttributes{\cc@opt@curcont\cc@eval@attributes}%
\def\cc@eval@attributes[#1]#2{%
%    \end{macrocode}
% First we check if the Container Instance has a dedicated Attribtue Type defined
%    \begin{macrocode}
  \expandafter\ifx\csname cc@type@#1@Attributes\endcsname\relax
%    \end{macrocode}
% If so, we parse the Attribute list.
%    \begin{macrocode}
    \ccParseAttributes{#1}{#2}%
%    \end{macrocode}
% After reading the Attribute list, we prepare unpacking the Attribute
% Data Type. Usually, the Type contains of a list of
% \UsageMacro{\ccDeclareAttributeHandler} statements, but it can also
% handle the Attributes directly. The Attribute handler macro is
% defined locally:
% \begin{macro}{\ccDeclareAttributeHandler*} declares an Attribute
%   handler. The \textit{starred} version is for Attributes that are
%   not expected to hold a value (i.\,e., switches), while the
%   \textit{non-starred} version is for Attributes that hold a value
%   (key-value pairs). The value(s) for each matching Attribute is
%   stored in \UsageMacro{\ccAttrVal}. You may want to copy that value
%   into another macro inside the third argument of the Handler macro
%   for later evaluation, as it will be redefined by an Attribute
%   Handler that is further down the Handler list.
%   \begin{ArgList}
%   \item[1] is the name of the attribute (i.\,e., the part before the
%     `=')
%   \item*[2] is code that is called when the Attribute does not occur
%     in the Attribute list \InlineArg{1}
%   \item[3] is code that is called when the Attribute does occur in
%     the Attribute list \InlineArg{1}.
%   \end{ArgList}
%    \begin{macrocode}
    \def\ccDeclareAttributeHandler{%
      \let\cc@is@starred\@undefined
      \@ifstar
        {\let\cc@is@starred\relax\cc@declare@attribute@handler}
        {\cc@declare@attribute@handler}}%
    \def\cc@declare@attribute@handler##1{\cc@opt@empty{\@cc@declare@attribute@handler{##1}}}
    \def\@cc@declare@attribute@handler##1[##2]##3{%
      \let\ccAttrVal\relax
      \ifx\cc@is@starred\relax
        \ccIfAttrIsSet{#1}{##1}{##3}{##2}%
      \else
        \ccIfAttr{#1}{##1}
          {\letcs\ccAttrVal{cc@#1@attr@##1}##3}
          {##2}%
      \fi\ignorespaces
    }%
%    \end{macrocode}
% \end{macro}
% With the Handler macro in place, we evaluate the Attributes data
% Type, thus parsing the Attributes.
%    \begin{macrocode}
    \ccEvalType{Attributes}%
  \else
%    \end{macrocode}
% If the Container has no Attributes type defined, we check if the
% Container instance has, in fact, Attributes
%    \begin{macrocode}
    \if!#2!\else
%    \end{macrocode}
% If so, we issue a warning since we cannot know how to deal with the
% Attributes.
%    \begin{macrocode}
      \ccPackageWarning{Kernel}{Attribute}
        {Container instance on line \inputlineno\space has Attributes,^^Jbut Container `#1' provides no Attribute handlers!}
    \fi
  \fi
  \ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccGetAttribute} returns the value of an attribute.
%   \begin{ArgList}
%   \item[1] is the attribute domain
%   \item[2] is the attribute name
%   \end{ArgList}
%    \begin{macrocode}
\def\ccGetAttribute#1#2{\csuse{cc@#1@attr@#2}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfAttr} can be used to call macros depending on
%   whether an attribute is set, or not.
%   \begin{ArgList}
%   \item[1] is the attribute domain
%   \item[2] is the attribute name
%   \item[3] is the \texttt{then} case
%   \item[4] is the \texttt{else} case
%   \end{ArgList}
%    \begin{macrocode}
\def\ccIfAttr#1#2#3#4{\ifcsdef{cc@#1@attr@#2}{#3}{#4}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccWhenAttr} is a variant of \lstinline{\ccIfAttr}
%   that omits the \textit{else} branch.
%   \begin{ArgList}
%   \item[1] is the attribute domain
%   \item[2] is the attribute name
%   \item[3] is the \texttt{then} case
%   \end{ArgList}
%    \begin{macrocode}
\def\ccWhenAttr#1#2#3{\ifcsdef{cc@#1@attr@#2}{#3}{}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUnlessAttr} is a variant of \lstinline{\ccIfAttr}
%   that omits the \textit{then} branch.
%   \begin{ArgList}
%   \item[1] is the attribute domain
%   \item[2] is the attribute name
%   \item[3] is the \texttt{else} case
%   \end{ArgList}
%    \begin{macrocode}
\def\ccUnlessAttr#1#2#3{\ifcsdef{cc@#1@attr@#2}{}{#3}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfAttrIsStr} can be used to call macros depending if
%   an attribute is set to the current (sub)container or group and what value it has.
%   \begin{ArgList}
%   \item[1] is the attribute domain
%   \item[2] is the attribute name
%   \item[3] is the comparing value
%   \item[4] is the \texttt{then} case
%   \item[5] is the \texttt{else} case
%   \end{ArgList}
%    \begin{macrocode}
\def\ccIfAttrIsStr#1#2#3#4#5{\ccIfAttr{#1}{#2}{\ifcsstring{cc@#1@attr@#2}{#3}{#4}{#5}}{#5}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccIfAttrIsSet} can be used to check if a value-less
%   attribute has been set (i.e., it expands to \lstinline{\@empty}).
%   \begin{ArgList}
%   \item[1] is the attribute domain
%   \item[2] is the attribute name
%   \item[3] is the \texttt{then} case
%   \item[4] is the \texttt{else} case
%   \end{ArgList}
%    \begin{macrocode}
\def\ccIfAttrIsSet#1#2#3#4{\ccIfAttr{#1}{#2}{\expandafter\ifx\csname cc@#1@attr@#2\endcsname\@empty#3\else#4\fi}{#4}}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Style Classes}
%
% Style Classes are locally usable sub-Containers.
%
% \TODO{Style Classes should be container-dependend. Better, yet,
% incorporate style classes into the new Attribute Type!}
%
% \begin{macro}{\ccDeclareClass}
%   The top-level macro \lstinline|\ccDeclareClass[#1]{#2}[#3]{#4}|
%   has four arguments, two of which are optional. \InlineArg{2} is
%   the name of the class. If this argument is empty, the special
%   class name \lstinline{default} is used. \InlineArg{4} is the
%   declaration block of the class. This argument usually contains a
%   set of Property assignments using the
%   \lstinline|\ccSetProperty{<prop>}{<val>}| macro, see
%   Sect.~\ref{sec:kernel:props}. The first optional argument
%   \InlineArg*{1} is the Style Class' parent Container. Using parent
%   Containers, you can have Style Classes of the same name for
%   different (sub-)Containers, e.g., a \lstinline{default} class for
%   each float and heading Container. The second optional argument
%   \InlineArg*{3} is the parent Style Class. Properties from that
%   Style Class are loaded automatically prior to the loading of the
%   current Style Class's Properties. This applies recursively
%   allowing for a cascading of property values, as in CSS.
%    \begin{macrocode}
\long\def\ccDeclareClass{\@ifnextchar [{\@cc@set@class}{\@cc@set@class[default]}}%]
\long\def\@cc@set@class[#1]#2{\cc@opt@empty{\cc@set@class[#1]{#2}}}%
\long\gdef\cc@default@class@default{}
\long\def\cc@set@class[#1]#2[#3]#4{%
  \def\@argii{#2}\ifx\@argii\@empty\let\@argii\cc@str@default\fi%
  \if!#3!\else
    \expandafter\long\expandafter\def\csname cc@#1@class@\@argii @parent\endcsname{#3}%
  \fi
  \expandafter\long\expandafter\def\csname cc@#1@class@\@argii\endcsname{#4}%
\ignorespaces}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccUseStyleClass}
%   is a user-level macro to expand and activate a Style Class'
%   Properties, those of its recursive ancestor Style Classes, and the
%   default Style Class respecting the current Container.
%   \begin{ArgList}
%   \item[1] is the Style Class name
%   \item[2] is the Container name
%   \end{ArgList}
%    \begin{macrocode}
\def\ccUseStyleClass#1#2{%
  \expandafter\ifx\csname cc@#2@class@#1\endcsname\relax
    \expandafter\ifx\csname cc@default@class@#1\endcsname\relax
      \PackageError{cocotex.cls}{Class `#1' with scope `#2' not defined!}{Please declare the class `#1'!}%
    \else
      \PackageWarning{cocotex.cls}{Class `#1' with scope `#2' not defined! Reverting to default.}%
    \fi
  \fi
  \csname cc@default@class@#1\endcsname%
  \expandafter\ifx\csname cc@#2@class@#1@parent\endcsname\relax\else
    \expandafter\ccUseStyleClass\expandafter{\csname cc@#2@class@#1@parent\endcsname}{#2}%
  \fi
  \csname cc@#2@class@#1\endcsname\ignorespaces}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{The {\CoCoTeX} Logo}
%
% \begin{macro}{\CoCoTeX} the {\CoCoTeX} Logo.
%    \begin{macrocode}
\DeclareRobustCommand\CoCoTeX{\texorpdfstring{{C\kern-.1em o\kern-.033emC\kern-.1em o}\kern-.133em\TeX}{CoCoTeX}}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}[numbers=none,gobble=1]
%</kernel>
%    \end{macrocode}
