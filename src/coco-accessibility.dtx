% \chapter{coco-accessibility.dtx}
%
% This file provides code for the interaction between the {\CoCoTeX}
% framwork and the \lstinline{ltpfdfa} package.
%
% \textbf{Please consider this module as highly experimental!}
%
% There are two files created from this dtx: one
% \lstinline{coco-accessibility.sty} and one
% \lstinline{coco-accrssibility.lua}.
%
%
% \section{LaTeX code}
%
%    \begin{macrocode}[gobble=1]
%<*a11y-sty>
%    \end{macrocode}
% \subsection{General Processing}
%
% The coco-accessibility.sty starts with some general package
% information like name, current version and date of last changes.
%    \begin{macrocode}
%%
%% Accessibility features for \textit{xerif} projects.
%%
%% Maintainer: p.schulz@le-tex.de
%%
%% lualatex  -  texlive > 2018
%%
\NeedsTeXFormat{LaTeX2e}[2018/12/01]
\ProvidesPackage{coco-accessibility}
    [\filedate \fileversion CoCoTeX accessibility module]
\RequirePackage{kvoptions-patch}
\RequirePackage{xkeyval}
\RequirePackage{atbegshi}
\RequirePackage{xparse}
%    \end{macrocode}
% The \lstinline{ltpdfa} package re-defines too many standard LaTeX
% macros, so we only use its lua code and define the interface
% ourself. For that, we use \lstinline{etoolbox}'s patch commands to
% inject our tagging code into the standard macros rather than to
% create hard copies. This should increase compatibility with other
% packages and make all our lifes easier.
%
% We start with adopting \lstinline{ltpdfa}'s package options.
% \begin{macro}{\cca@lang@id} is the ISO 639-2 code for the document's
%   main language. As default, we assume Modern English.
%    \begin{macrocode}
\def\cca@lang@id{eng}%
\DeclareOptionX{lang-id}{\gdef\cca@lang@id{#1}}
%    \end{macrocode}
% \end{macro}
%    \begin{macrocode}
\DeclareOptionX{init}{\global\let\cc@do@ally\relax}
%    \end{macrocode}
% \begin{macro}{\cca@do@nodetree} if \lstinline{\relax}, show the node tree in
%   the log and in the shell output.
%    \begin{macrocode}
\DeclareOptionX{nodetree}{\let\cca@do@nodetree\relax}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cca@do@showspaces} if \lstinline{\relax}, show spaces
%   in the pdf.
%    \begin{macrocode}
\DeclareOptionX{show-spaces}{\let\cca@do@showspaces\relax}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cca@do@dospaces} if \lstinline{\relax}, add
%   ASCII space characters to the PDF. {\LaTeX} doesn't write physical
%   spaces into the output document but moves letters via skips, which
%   allows variable word spacing beyond a font's space width
%   definition, but it is a hard barrier for screen readers which rely
%   on real space characters. This options causes the
%   \lstinline{ltpdfa} package to insert real space characters that
%   are immediately followed by a negative skip by the font-dependend
%   width of that space to keep \LaTeX's typeface intact. This is
%   activated by default.
%    \begin{macrocode}
\let\cca@do@dospaces\relax
\DeclareOptionX{no-spaces}{\let\cca@do@dospaces\@undefined}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cca@do@doparas} if \lstinline{\relax}, add paragraph
%   tagging.
%    \begin{macrocode}
\let\cca@do@doparas\relax
\DeclareOptionX{no-paras}{\let\cca@do@doparas\@undefined}
%    \end{macrocode}
% \end{macro}
% Processing the options.
%    \begin{macrocode}
\ProcessOptionsX
%    \end{macrocode}
%
% \begin{macro}{\cca@patch@error} is a generic error message that is
%   thrown whenever a {\LaTeX} kernel macro could not be patched. This
%   is usually the case when the macro definition does not match
%   coco-accessibility's expectation, e.g., when another package
%   messes with the macro's original definition. \#1 is the CS token
%   of the un-patchable macro.
%    \begin{macrocode}
\def\cca@patch@error#1{%
  \ccPackageError{a11y}{compatibility}
  {Could not patch \noexpand#1}
  {You probably use a LaTeX package that re-defines the \noexpand#1 control sequence. It is apparently not compatbile with coco-accessibility.sty. Sorry}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Activating and Deactivating  Accessibility Features}
%
% \begin{macro}{\ccIfAlly} is a switch to distinct between compilation
%   with (implicit \#1) or without (implicit \#2) activated accessibility features.
%    \begin{macrocode}
\def\cc@if@ally{\ifx\cc@do@ally\relax\expandafter\@firstoftwo\else\expandafter\@secondoftwo\fi}
\let\ccIfAlly\cc@if@ally
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccWhenAlly} is a variant of \lstinline{\ccIfAlly}
%   that omits the else branch.
%    \begin{macrocode}
\def\ccWhenAlly{\ifx\cc@do@ally\relax\expandafter\@firstofone\else\expandafter\@gobble\fi}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Accessibility-specific additions}
%
% \subsubsection{Loading Further Dependencies}
%
% Activated coco-accessibility requires two packages:
% \lstinline{luatexbase-attr} (possibly deprecated?) provides an
% interface to add attributes to lua code; \lstinline{atveryend}
% provides a hook to inject code to the final stages of PDF rendering.
%    \begin{macrocode}
\ccWhenAlly{%
  \ifluatex\else
    \ccPackageError{a11y}{engine}
      {accessibility features require lualatex!}
      {You tried to use the accessibility features of CoCoTeX with an other TeX engine than lualatex. This will not work; lualatex is a hard requirement. Sorry.}
  \fi
  \RequirePackage{luatexbase-attr}
  \RequirePackage{atveryend}
%    \end{macrocode}
%
%
% \subsubsection{Additonal Hyperref Setup}
%
% Additional hyperref setup to be executed at the very end of the
% preamble.
%    \begin{macrocode}
  \AtBeginDocument{%
    \hypersetup{%
      % pdfa=true% already set elsewhere
      ,unicode=true%
      ,pdfinfo={}%
      % ,pdfpagelabels=true% already set elsewhere
      ,pageanchor=true%
    }%
    \Hy@pdfatrue
  }
%    \end{macrocode}
%
%
% \subsubsection{Loading and Configuring ltpdfa's Lua Modules}
%
% Now, we set the configuration of the \lstinline{ltpdfa} lua facility
% by passing some of the \lstinline{coco-accessibility} package
% options:
%    \begin{macrocode}
  \directlua{ltpdfa = require('ltpdfa')}
  \directlua{ltpdfa.config.final = true}
  \directlua{ltpdfa.config.debug = \if@cc@debug true\else false\fi}
  \directlua{ltpdfa.config.nodetree = \ifx\cca@do@nodetree\relax true\else false\fi}
  \directlua{ltpdfa.config.showspaces = \ifx\cca@do@showspaces\relax true\else false\fi}
  \directlua{ltpdfa.config.dospaces = \ifx\cca@do@dospaces\relax true\else false\fi}
  \directlua{ltpdfa.config.doparas = \ifx\cca@do@doparas\relax true\else false\fi}
%    \end{macrocode}
% \lstinline{ltpdfa} provides two ways to tag heading heads. One by
% tagging headers as \lstinline{H1..H6}, and one where all headings
% are tagged as \lstinline{H} and a heading's depth is implied by
% nesting. Since most of our projects require way more than 6 heading
% levels, we hard-code the nesting approach:
%    \begin{macrocode}
  \directlua{ltpdfa.config.headnums = false}
%    \end{macrocode}
% CoCoTeX with accessibility support is \lstinline{\luaTeX} only, so
% we hard-code \lstinline{pdftex} as render engine:
%    \begin{macrocode}
  \directlua{ltpdfa.config.driver = "\luaescapestring{pdftex}"}
  \directlua{ltpdfa.config.lang = '\luaescapestring{\cca@lang@id}'}
  \directlua{ltpdfa.init()}%
%    \end{macrocode}
% Initial setup of ltpdfa
%    \begin{macrocode}
  \edef\@ltpdfa@pattr{\directlua{ltpdfa.getAttribute('\luaescapestring{parentattr}')}}
  \edef\@ltpdfa@tattr{\directlua{ltpdfa.getAttribute('\luaescapestring{typeattr}')}}
  \attributedef\@ltpdfa@typeattr=\@ltpdfa@tattr
  \attributedef\@ltpdfa@parentattr=\@ltpdfa@pattr
  \def\ltpdfa@last@page{\ifx\r@LTLastPage\undefined\@empty\else\expandafter\@secondoftwo\r@LTLastPage\fi}%
%    \end{macrocode}
% We need the absolute last page of the document
%    \begin{macrocode}
  \AfterLastShipout{\immediate\write\@mainaux{\string\newlabel{LTLastPage}{{LTLastPage}{\directlua{ltpdfa.getPageNum()}}}}}%
}%/ccWhenAlly
%    \end{macrocode}
%
% \subsection{Generic Macro to Declare Accessibility Features}
%
% In order to selectively enable and disable accessibility macros
% during runtime, we need each tagging markup macro to exist in two
% states, one where they trigger tagging into the pdf, and one where
% they do nothing.
%
% The enabled and disabled versions of each macro are stored inside
% two seperate lists:
% \begin{macro}{\cca@relaxed@defs} is the list that stores the
%   \textit{disabled} ltpdfa interface command variants,
%    \begin{macrocode}
\def\cca@relaxed@defs{}
%    \end{macrocode}
% \end{macro}
% and
% \begin{macro}{\cca@saved@defs} is a list that stores the
%   \textit{enabled} ltpdfa interface command variants.
%    \begin{macrocode}
\def\cca@saved@defs{}
%    \end{macrocode}
% \end{macro}
% The next two macros are used to disable and enable accessibility
% markup:
% \begin{macro}{\ccaDisable} disables all ltpdfa commands
%    \begin{macrocode}
\def\ccaDisable{\cca@relaxed@defs}
%    \end{macrocode}
% \end{macro}
% and
% \begin{macro}{\ccaEnable} enables all ltpdfa commands.
%    \begin{macrocode}
\def\ccaEnable{\cca@saved@defs}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\CsToStr} is a xparse helper macro which returns the name of
%   a control sequence \#1.
%    \begin{macrocode}
\ExplSyntaxOn
\newcommand{\CsToStr}[1]{\cs_to_str:N #1}
\ExplSyntaxOff
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\DeclareAccessibilityCommand} is the wrapper for our
%   interface macros. It has the same argument signature as \LaTeX's
%   \lstinline{\newcommand*}, albeit without the whole checking for
%   already defined control sequences.
%    \begin{macrocode}
\def\DeclareAccessibilityCommand#1{\@ifnextchar[{\cca@declare@cmd@firstopt#1}{\cca@declare@cmd#1}}%]
%    \end{macrocode}
%   First, we need to take care of the optional arguments:
% \begin{macro}{\cca@temp@signature} is the temporary storage for the
%   argument signature.
%    \begin{macrocode}
\let\cca@temp@signature\@empty
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cca@declare@cmd@firstopt} is the handler for the
%   first optional argument, which holds the overall number of the
%   arguments of our interface macro:
%    \begin{macrocode}
\def\cca@declare@cmd@firstopt#1[#2]{\edef\cca@temp@signature{[\unexpanded{#2}]}%
  \@ifnextchar[{\cca@declare@cmd@secopt#1}{\cca@declare@cmd#1}}%]
%    \end{macrocode}
%   \end{macro}
%   \begin{macro}{\cca@declare@cmd@secopt} is the handler for the second
%     optional argument, which indicates that the first of the
%     first-level arguments is optional and which itself holds the
%     default value for that optional argument. Its unexpanded value is added to
%     the argument signature.
%    \begin{macrocode}
\def\cca@declare@cmd@secopt#1[#2]{\eappto\cca@temp@signature{[\unexpanded{#2}]}\cca@declare@cmd#1}
%    \end{macrocode}
%   \end{macro}
%   \begin{macro}{\cca@declare@cmd}, eventually, is the actual wrapper
%     for the newcommand calls.
%    \begin{macrocode}
\def\cca@declare@cmd#1#2{%
%    \end{macrocode}
% First, we create a string \lstinline{\savedDef} that includes the
% \textit{active} definition of our interface macro and store it in an
% internal macro named \lstinline{\cc@saved@#1}. This macro is
% immediately called.
%    \begin{macrocode}
  \edef\savedDef{\noexpand\newcommand*\expandafter\noexpand\csname cc@saved@\CsToStr{#1}\endcsname\expandonce{\cca@temp@signature}{\unexpanded{#2}}}\savedDef%
%    \end{macrocode}
% Then, we create a \lstinline{\let} sequence that maps the plain CS
% name \#1 onto that newly created internal macro. The String
% containing the let-sequence is then stored in the {\cca@saved@defs}
% list, so whenever this list is expanded, the desired CS-token
% ``\#1'' is defined to the active definition.
%    \begin{macrocode}
  \edef\x{\noexpand\let\noexpand#1\expandafter\noexpand\csname cc@saved@\CsToStr{#1}\endcsname}%
  \global\expandafter\appto\expandafter\cca@saved@defs\expandafter{\x}%
%    \end{macrocode}
% Then, we repeat the same procedure, but this time, we define the
% whole internal CS token with the same argument structure to expand
% to \lstinline{\relax}.
%    \begin{macrocode}
  \edef\relaxDef{\noexpand\newcommand*\expandafter\noexpand\csname cc@no@\CsToStr{#1}\endcsname\expandonce{\cca@temp@signature}{\relax}}\relaxDef%
%    \end{macrocode}
% The whole \lstinline{\let} sequence for the \lstinline{\relax}
% version of our internal macro is then stored in the
% \lstinline{\cca@relaxed@defs} list.
%    \begin{macrocode}
  \edef\y{\noexpand\let\noexpand#1\expandafter\noexpand\csname cc@no@\CsToStr{#1}\endcsname}%
  \expandafter\appto\expandafter\cca@relaxed@defs\expandafter{\y}%
%    \end{macrocode}
% Now, we can decide which of the two \lstinline{\let}-sequences
% should be the used to define the initial value of the \#1 CS token,
% depending on the value of the \lstinline{\ccIfAlly} conditional:
%    \begin{macrocode}
  \ccIfAlly{\x}{\y}%
%    \end{macrocode}
% Finally, we reset the temporary argument signature macro.
%    \begin{macrocode}
  \let\cca@temp@signature\@empty
}
%    \end{macrocode}
%   \end{macro}
% \end{macro}
% Some macros from \lstinline{ltpdfa.sty}:
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaAddToConfig}[2]{\directlua{ltpdfa.addToConfig('\luaescapestring{#1}','\luaescapestring{#2}')}}
\@onlypreamble\ccaAddToConfig
%    \end{macrocode}
% \begin{macro}{\ccaStructStart, \ccaStructEnd} inserts a structural
%   tag with the name \#2. Optional \#1 is the name of a forced
%   parent.
%
%   This tagging macro inserts \lstinline{\bgroup} and
%     \lstinline{\egroup} around the tagged area.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaStructStart}[2][]{\directlua{ltpdfa.tagger.structStart('\luaescapestring{#2}','\luaescapestring{#1}')}}
\DeclareAccessibilityCommand{\ccaStructEnd}[1]{\directlua{ltpdfa.tagger.structEnd('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccaVstructStart,\ccaVstructEnd} are the same as
%   \lstinline{\ccaStructStart} and \lstinline{\ccaStructEnd} but
%   without grouping the area.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaVstructStart}[2][]{\directlua{ltpdfa.tagger.vstructStart('\luaescapestring{#2}','\luaescapestring{#1}')}}
\DeclareAccessibilityCommand{\ccaVstructEnd}[1]{\directlua{ltpdfa.tagger.vstructEnd('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccaPstructStart, \ccaPstructEnd} same as
%   \lstinline{\ccaStructStart} and \lstinline{\ccaStructEnd} but no
%   grouping and not setting any attributes. Implies that the element
%   has no content children, at all.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaPstructStart}[2][]{\directlua{ltpdfa.tagger.pstructStart('\luaescapestring{#2}','\luaescapestring{#1}')}}
\DeclareAccessibilityCommand{\ccaPstructEnd}[1]{\directlua{ltpdfa.tagger.pstructEnd('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cca@set@docinfo} sets the PDF docinfo. \#2 is a key,
%   \#3 is the value, optional \#1 is an encoding.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaSetDocinfo}[3][]{\directlua{ltpdfa.setDocInfo('\luaescapestring{#2}','\luaescapestring{#3}','\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ccaAddRolemap} is used to map a custom LaTeX tag to
%   a well-defined PDF tag. \#1 is the name of the LateX Tag, \#2 is
%   the name of the PDF role.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaAddRolemap}[2]{\directlua{ltpdfa.tagger.addRolemap('\luaescapestring{#1}','\luaescapestring{#2}')}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccaAddPlacement} ???
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaAddPlacement}[1]{\directlua{ltpdfa.tagger.addPlacement('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccaAddNumbering} ???
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaAddNumbering}[1]{\directlua{ltpdfa.tagger.addNumbering('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Lua injection}
%
% Some features are realized by Lua code, so we tell LuaLaTeX to
% include the code that is generated from material later in this
% source file:
%    \begin{macrocode}
\ccWhenAlly{\directlua{ally = require('coco-accessibility')}}
%    \end{macrocode}
%
%
% \subsection{Hyperlink handling}
%
% To tag hyperlinks, we define some ltpdfa interface macros.
%
% \begin{macro}{\ccaAddAltText} is used to add an Alternative Text
%   node, given in \#1, to the PDF structTree.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaAddAltText}[1]{\directlua{ltpdfa.tagger.addAltText('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ccaAddLastLink} adds the last Link node to the PDF
%   structTree.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaAddLastLink}{\directlua{ltpdfa.tagger.addLastLink()}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ccaGetStructParent} returns the current parent
%   structure. This is needed in case a link breaks across columns (or
%   pages).
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaGetStructParent}{\directlua{ltpdfa.tagger.getStructParent()}}
%    \end{macrocode}
% \end{macro}
% We prepare the link interface macros to be patched into
% \lstinline{hyperref} at the begin document hook if accessibility
% features are activated.
%
% First we add the start tag for a Link node.
%    \begin{macrocode}
\begingroup
\@makeother\#
\ccWhenAlly{%
\AtBeginDocument{%
    \patchcmd\Hy@StartlinkName
      {\pdfstartlink}
      {\ccaStructStart{Link}\ccaAddAltText{#2}\edef\@ltpdfmy@parent{\ccaGetStructParent}%
       \pdfstartlink}
      {}{\cca@patch@error\Hy@StartlinkName}
%    \end{macrocode}
% and the parent node inside the link attribute:
%    \begin{macrocode}
    \patchcmd\Hy@StartlinkName
      {#1}
      {#1 /StructParent \@ltpdfmy@parent}
      {}{\cca@patch@error\Hy@StartlinkName}
%    \end{macrocode}
% then we patch hyperref's general link macro, twice. Once for the Link's start tag
%    \begin{macrocode}
    \patchcmd\hyper@linkurl
      {\pdfstartlink}
      {\ccaStructStart{Link}\ccaAddAltText{#2}\edef\@ltpdfmy@parent{\ccaGetStructParent}%
        \pdfstartlink}
      {}{\cca@patch@error\hyper@linkurl}
%    \end{macrocode}
% and secondly for the Parent:
%    \begin{macrocode}
    \patchcmd\hyper@linkurl
      {/C[\@urlbordercolor]%
        \fi
      }
      {/C[\@urlbordercolor]%
        \fi
        /StructParent \@ltpdfmy@parent%
      }{}{\cca@patch@error\hyper@linkurl}
%    \end{macrocode}
% finally, we patch the end tag for the link node into the
% \lstinline{\close@pdflink} macro:
%    \begin{macrocode}
    \patchcmd\close@pdflink
      {\pdfendlink}
      {\pdfendlink
        \ccaAddLastLink\ccaStructEnd{Link}}
      {}{\cca@patch@error\close@pdflink}
%    \end{macrocode}
% For internal references, we patch the tagging into the
% \lstinline{\@setref} macro. Unfortunately, hyperref redefines this
% macro and links to both the original version (when \lstinline{\ref*}
% is used), and its own re-definition (else), so we need to patch both
% versions. We start by resetting \lstinline{\@setref} to its vanilla
% state and inject our tagging, once for the start tag and a second
% time for the end tag:
%    \begin{macrocode}
    \let\cca@hy@setref\@setref
    \let\@setref\real@setref
    \patchcmd\@setref
      {\else}
      {\else\ccaStructStart{Reference}}
      {}{\cca@patch@error\orig@setref@new}%
    \patchcmd\@setref
      {\fi}
      {\ccaStructEnd{Reference}\fi}
      {}{\cca@patch@error\orig@setref@new}%
%    \end{macrocode}
% Now, we restore hyperref's version and inject the tagging there as
% well:
%    \begin{macrocode}
    \let\real@setref\@setref
    \let\@setref\cca@hy@setref
    \patchcmd\@setref
      {\expandafter\Hy@setref@link}
      {\ccaStructStart{Reference}\expandafter\Hy@setref@link}
      {}{\cca@patch@error\@setref}
    \patchcmd\@setref
      {{#2}}
      {{#2}\ccaStructEnd{Reference}}
      {}{\cca@patch@error\@setref}
    }% /AtBeginDocument
}% /ccWhenAlly
\endgroup
%    \end{macrocode}
%
% \subsection{Tagging Page Styles as Artifacts}
%
% Page styles, i.e., headers and footers need to be tagged as
% artifacts unless they contain semantic information. To avoid
% inserting the tagging by hand into each publisher's page style
% definitions, we inject the tagging automatically by using
% \lstinline{etoolbox}'s patch commands to insert the start and end
% tags inside the internal header and footer macros, respectively.
%
% \begin{macro}{\ccaPagestyleArtifacts} contains the code to patch the
%   \lstinline{\@oddhead}, \lstinline{\@evenhead},
%   \lstinline{\@oddfoot} and \lstinline{\@evenfoot} macros.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaPagestyleArtifacts}{%
  \ifx\@oddhead\@empty\else
    \pretocmd\@oddhead{\ccaStructStart[document]{header}}{}{}%
    \apptocmd\@oddhead{\ccaStructEnd{header}}{}{}%
  \fi
  \ifx\@evenhead\@empty\else
    \pretocmd\@evenhead{\ccaStructStart[document]{header}}{}{}%
    \apptocmd\@evenhead{\ccaStructEnd{header}}{}{}%
  \fi
  \ifx\@oddfoot\@empty\else
    \pretocmd\@oddfoot{\ccaStructStart[document]{footer}}{}{}%
    \apptocmd\@oddfoot{\ccaStructEnd{footer}}{}{}%
  \fi
  \ifx\@evenfoot\@empty\else
    \pretocmd\@evenfoot{\ccaStructStart[document]{footer}}{}{}%
    \apptocmd\@evenfoot{\ccaStructEnd{footer}}{}{}%
  \fi}
%    \end{macrocode}
% \end{macro}
% The standard pagestyles from the {\LaTeX} kernel are patched
% by the module.
%    \begin{macrocode}
\apptocmd\ps@empty{\ccaPagestyleArtifacts}{}{}
\apptocmd\ps@plain{\ccaPagestyleArtifacts}{}{}
\apptocmd\ps@headings{\ccaPagestyleArtifacts}{}{}
\apptocmd\ps@myheadings{\ccaPagestyleArtifacts}{}{}
%    \end{macrocode}
% Finally, we register the \lstinline{footer} and \lstinline{header}
% PDF tags as \lstinline{artifacts} with \lstinline{ltpdfa}:
%    \begin{macrocode}
\ccWhenAlly{%
  \ccaAddToConfig{artifact}{header={Type:Pagination}{Subtype:Header}}
  \ccaAddToConfig{artifact}{footer={Type:Pagination}{Subtype:Footer}}
%    \end{macrocode}
%
%\subsection{generic artifacts}
%
%    \begin{macrocode}
  \ccaAddToConfig{artifact}{leaders={Type:Layout}}
  \ccaAddToConfig{artifact}{footnoterule={Type:Layout}}
  \ccaAddToConfig{artifact}{Artifact={Type:Layout}}
}
%    \end{macrocode}
%
% \subsection{Tagging for Floats}
%
% \subsubsection{Taggin for Figures}
%
% \begin{macro}{\ccaAddFigure} \#1, \#2, \#3, and \#4 are the x and y
%   coordinates of the image, first x and y of the lower left corner,
%   then x and y of the upper right corner; \#5 and \#6 are the $x$
%   and $y$ scales, respectively; and \#7 is ``true'' or ``false''
%   depending on whether or not the clipping option is active.
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaAddFigure}[7]{\directlua{ltpdfa.tagger.addFigure(
    '\luaescapestring{#1}',
    '\luaescapestring{#2}',
    '\luaescapestring{#3}',
    '\luaescapestring{#4}',
    '\luaescapestring{#5}',
    '\luaescapestring{#6}',
    '\luaescapestring{#7}')}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ccaFigureStart} injects the starting tag for images to the pdf
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaFigureStart}[1]{\directlua{ltpdfa.tagger.figureStart('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccaFigureEnd} injects the ending tag for images
%    \begin{macrocode}
\DeclareAccessibilityCommand{\ccaFigureEnd}[1]{\directlua{ltpdfa.tagger.figureEnd('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% which we add to the beginning and the end of \lstinline{graphics}
% package's \lstinline{\Ginclude@graphics} macro, respectively.
%    \begin{macrocode}
\AtBeginDocument{%
  \if@cc@modern
    \let\ltx@Ginclulde@graphics\Ginclude@graphics
    \def\Ginclude@graphics#1{\if@cc@is@final\ccaFigureStart{}\fi\ltx@Ginclulde@graphics{#1}\if@cc@is@final\ccaFigureEnd{}\fi}%
  \else
    \@ifpackageloaded{grffile}
      {\pretocmd\grffile@Ginclude@graphics{\if@cc@is@final\ccaFigureStart{}\fi}{}{}%
       \apptocmd\grffile@Ginclude@graphics{\if@cc@is@final\ccaFigureEnd{}\fi}{}{}}
      {\pretocmd\Ginclude@graphics{\if@cc@is@final\ccaFigureStart{}\fi}{}{}%
       \apptocmd\Ginclude@graphics{\if@cc@is@final\ccaFigureEnd{}\fi}{}{}}%
  \fi
}
%    \end{macrocode}
%
%    \begin{macrocode}
\apptocmd\Ginclude@@pdftex{\if@cc@is@final%
  \def\@tempa{!}%
  \ccaAddFigure{\Gin@llx}{\Gin@lly}{\Gin@urx}{\Gin@ury}
    {\ifx\Gin@scalex\@tempa\else \Gin@scalex\fi}
    {\ifx\Gin@scaley\@tempa\else \Gin@scaley\fi}
    {\ifGin@clip true\else false\fi}\fi}%rwi/rhi
    {}{}
\AtBeginDocument{%
  \@ifpackageloaded{htmltabs}{%
    \let\ltx@ht@valign@box\ht@valign@box
    \def\ht@valign@box{\if@ht@final@render\@cc@is@finaltrue\fi\ltx@ht@valign@box}
    \let\ltx@ht@RenderCell\ht@RenderCell
    \def\ltx@ht@RenderCell{\@cc@is@finalfalse\ltx@ht@RenderCell}}{}}
%    \end{macrocode}
%
%
% \subsection{Transformation of  Typographic Unicode characters}
%
% In order for screen readers to work correctly, some unicode
% characters that mask purely typographic glyphs (e.g., ligatures)
% need to be mapped to their underlaying orthographic characters. This
% is done via pdftex's \lstinline{glyphtounicode} tables:
%    \begin{macrocode}
\ifx\pdfextension\@undefined\else
\protected\def\pdfglyphtounicode{\pdfextension glyphtounicode}
\input glyphtounicode
\edef\pdfgentounicode{\pdfvariable gentounicode}
\pdfgentounicode = 1
\fi
%    \end{macrocode}
%
% \subsection{Automatic PDF Tagging}
%
% \subsubsection{Document Root Node}
%
% The following code causes the ltpdfa package to tag the
% \lstinline{document} environmant as the structural representation's
% root node:
%    \begin{macrocode}
\ccWhenAlly{%
  \ccDeclareHook[document]{cca/at/begin/document}
  \AtBeginDocument{%
    \directlua{ltpdfa.beginDocument('\luaescapestring{\ltpdfa@last@page}')}
    \ccUseHook[document]{cca/at/begin/document}%
    \directlua{ltpdfa.configAutoclose()}
    \ccaVstructStart{document}%
  }
  \AtEndDocument{%
    \ccaVstructEnd{document}
    \directlua{ltpdfa.endDocument()}%
  }
}
%    \end{macrocode}
%
%
% \section{Default Role Mapping}
%
% Note that this section contains only the role mappings that didn't
% thematically fit into other {\CoCoTeX} modules.
%
%    \begin{macrocode}
\ccaAddRolemap{document}{Document}
\ccaAddRolemap{Para}{P}
%    \end{macrocode}
% Finally, we hook \lstinline{ltpdfa}'s page processor into
% \lstinline{AtBeginShipoutBox}:
%    \begin{macrocode}
\ccWhenAlly{\AtBeginShipout{\directlua{ltpdfa.pageprocessor(tex.box["AtBeginShipoutBox"])}}}%
%    \end{macrocode}
% End of {\TeX} source code.
%    \begin{macrocode}[gobble=1]
%</a11y-sty>
%    \end{macrocode}
%
%    \begin{macrocode}[gobble=1]
%<*a11y-lua>
%    \end{macrocode}
%
% \section{Lua code}
%
% \subsection{Local Variables and Tables}
%
% \lstinline{ltpdfa} is an instance of the \lstinline{ltpdfa} Lua
%   table.
%    \begin{macrocode}[language={[5.3]Lua}]
local ltpdfa = require('ltpdfa')
%    \end{macrocode}
%
% \subsection{Meta Data Extraction}
%
%
% \lstinline{meta} is a table that holds the metadata that are
% extracted from the \lstinline{\jobname.xmp} file via its
% \lstinline{extract} member.
%    \begin{macrocode}[language={[5.3]Lua}]
local meta = {
  Author = '',
  Title = '',
  Creator = '',
  Producer = '',
  Keywords = '',
%    \end{macrocode}
% The method \lstinline{meta.extract()} reads the meta data
% from the \lstinline{\jobname.xmp} and stores certain values to be
% accessed by LaTeX. This is used to fill the DocumentInfo when a xmp
% file is available during the expansion of
% \lstinline{\cct@write@pdf@meta} from the coco-title module (see
% Sect.~\ref{sect:coco-title:pdf-meta-data}).
%    \begin{macrocode}[language={[5.3]Lua}]
  extract = function ()
    local xmpfile = ltpdfa.metadata.xmphandler.fromFile(ltpdfa.config.metadata.xmpfile)
    local f = io.open(xmpfile, "r")
    local content = f:read("*all")
    f:close()


    if (content:find('<dc:title>')) then
      Title = content:gsub('.*<dc:title>[^<]*<rdf:Alt>[^<]*<rdf:li[^>]*>(.*)</rdf:li>[^<]*</rdf:Alt>[^<]*</dc:title>.*', "%1")
      -- log(">>>" .. meta.Title)
    end

    local authors
    local author = {}
    if (content:find('<dc:creator>')) then
      authors = content:gsub('.*<dc:creator>[^<]*<rdf:Seq>(.*)</rdf:Seq>[^<]*</dc:creator>.*', "%1")
      for k in string.gmatch(authors, "<rdf:li>([^>]+)</rdf:li>") do
        table.insert(author , k)
      end
      Author = table.concat(author, ', ')
    end
  end
}
%    \end{macrocode}
%
% \subsection{Public Methods}
%
% \lstinline{cocotex} is the base table that contains all public
%   methods and sub-tables available in the {\CoCoTeX}
%   framework. Here, it is defined unless it is already defined
%   elsewhere.
%    \begin{macrocode}[language={[5.3]Lua}]
if type(cocotex) ~= 'table' then
  cocotex = {}
end
%    \end{macrocode}
% \lstinline{cocotex.ally} is a globally available namespace for
%   coco-accessibility specific lua tables.
%    \begin{macrocode}[language={[5.3]Lua}]
cocotex.ally = {
  meta = meta
}
%    \end{macrocode}
%
% After loading \lstinline{coco-accessibility.lua} via the
% \lstinline[language={[5.3]Lua}]{require()} method, a
% \lstinline[language={[5.3]Lua}]{cocotex.ally} table is returned.
%    \begin{macrocode}[language={[5.3]Lua}]
return cocotex.ally
%    \end{macrocode}
% no more lua code.
%    \begin{macrocode}[gobble=1]
%</a11y-lua>
%    \end{macrocode}
