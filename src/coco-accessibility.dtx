% \chapter{coco-accessibility.dtx}
%
% This file provides code for the interaction between the {\CoCoTeX}
% framwork and the \lstinline{ltpfdfa} package.
%
% \textbf{Please consider this module as highly experimental!}
%
% There are two files created from this dtx: one
% \lstinline{coco-accessibility.sty} and one
% \lstinline{coco-accrssibility.lua}.
%
%
% \section{LaTeX code}
%
%    \begin{macrocode}[gobble=1]
%<*a11y-sty>
%    \end{macrocode}
% \subsection{General Processing}
%
% The coco-accessibility.sty starts with some general package
% information like name, current version and date of last changes.
%    \begin{macrocode}
%%
%% Accessibility features for \textit{xerif} projects.
%%
%% Maintainer: p.schulz@le-tex.de
%%
%% lualatex  -  texlive > 2018
%%
\NeedsTeXFormat{LaTeX2e}[2018/12/01]
\ProvidesPackage{coco-accessibility}
    [\filedate \fileversion CoCoTeX accessibility module]
%    \end{macrocode}
% \begin{macro}{\tp@if@ally} If the \lstinline{coco-ally} package is
%   loaded, the conditional from the \lstinline{coco-common} module is
%   re-defined to always expand the \texttt{true} branch and discard
%   the \texttt{false} branch:
%    \begin{macrocode}
\def\cc@if@ally{\expandafter\@firstoftwo}
%    \end{macrocode}
% \end{macro}
% The \lstinline{ltpdfa} package re-defines too many standard LaTeX
% macros, so we only use its lua code and define the interface
% ourself. For that, we use \lstinline{etoolbox}'s patch commands to
% inject our tagging code into the standard macros rather than to
% create hard copies. This should increase compatibility with other
% packages and make all our lifes easier.
%
% We start with ltpdfa's package options.
% 
% \begin{macro}{\cca@lang@id} is the ISO 639-2 code for the document's
%   main language. As default, we assume Modern English.
%    \begin{macrocode}
\def\cca@lang@id{eng}%
\DeclareOptionX{lang-id}{\gdef\cca@lang@id{#1}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cca@do@nodetree} if \lstinline{\relax}, show the node tree in
%   the log and in the shell output.
%    \begin{macrocode}
\DeclareOptionX{nodetree}{\let\cca@do@nodetree\relax}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cca@do@showspaces} if \lstinline{\relax}, show spaces
%   in the pdf.
%    \begin{macrocode}
\DeclareOptionX{show-spaces}{\let\cca@do@showspaces\relax}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\cca@do@dospaces} if \lstinline{\relax}, add
%   ASCII space characters to the PDF. {\LaTeX} doesn't write physical
%   spaces into the output document but moves letters via skips, which
%   allows variable word spacing beyond a font's space width
%   definition, but it is a hard barrier for screen readers which rely
%   on real space characters. This options causes the
%   \lstinline{ltpdfa} package to insert real space characters that
%   are immediately followed by a negative skip by the font-dependend
%   width of that space to keep \LaTeX's typeface intact. This is
%   activated by default.
%    \begin{macrocode}
\let\cca@do@dospaces\relax
\DeclareOptionX{no-spaces}{\let\cca@do@dospaces\@undefined}
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cca@do@doparas} if \lstinline{\relax}, add paragraph
%   tagging.
%    \begin{macrocode}
\let\cca@do@doparas\relax
\DeclareOptionX{no-paras}{\let\cca@do@doparas\@undefined}
%    \end{macrocode}
% \end{macro}
% Process the options.
%    \begin{macrocode}
\ProcessOptionsX
%    \end{macrocode}
% 
%    \begin{macrocode}
\def\cca@patch@error#1{%
  \ccPackageError{a11y}{compatibility}
  {Could not patch \noexpand#1}
  {You probably use a LaTeX package that re-defines hyperref's \noexpand#1 macro. It is apparently not compatbile with coco-accessibility.sty. Sorry}}
%    \end{macrocode}
% then we need to packages. \lstinline{luatexbase-attr} (possibly
% deprecated?) provides an interface to add attributes to lua code;
% \lstinline{atveryend} provides a hook to inject code to the final
% steps of rendering.
%    \begin{macrocode}
\RequirePackage{luatexbase-attr}
\RequirePackage{atveryend}
%    \end{macrocode}
% Now, we set the configuration of the \lstinline{ltpdfa} lua facility
% by passing some of the \lstinline{coco-accessibility} package
% options:
%    \begin{macrocode}
\directlua{ltpdfa = require('ltpdfa')}
\directlua{ltpdfa.config.final = true}
\directlua{ltpdfa.config.debug = \if@tp@debug true\else false\fi}
\directlua{ltpdfa.config.nodetree = \ifx\cca@do@nodetree\relax true\else false\fi}
\directlua{ltpdfa.config.showspaces = \ifx\cca@do@showspaces\relax true\else false\fi}
\directlua{ltpdfa.config.dospaces = \ifx\cca@do@dospaces\relax true\else false\fi}
\directlua{ltpdfa.config.doparas = \ifx\cca@do@doparas\relax true\else false\fi}
%    \end{macrocode}
% \lstinline{ltpdfa} provides two ways to tag heading heads. One by
% tagging headers as \lstinline{H1..H6}, and one where all headings
% are tagged as \lstinline{H} and a heading's depth is implied by
% nesting. Since most of our projects require way more than 6 heading
% levels, we hard-code the nesting approach:
%    \begin{macrocode}
\directlua{ltpdfa.config.headnums = false}
%    \end{macrocode}
% CoCoTeX with accessibility support is \lstinline{\luaTeX} only, so
% we hard-code \lstinline{pdftex} as render engine:
%    \begin{macrocode}
\directlua{ltpdfa.config.driver = "\luaescapestring{pdftex}"}
\directlua{ltpdfa.config.lang = '\luaescapestring{\cca@lang@id}'}
\directlua{ltpdfa.init()}%
%    \end{macrocode}
% Initial setup of ltpdfa
%    \begin{macrocode}
\edef\@ltpdfa@pattr{\directlua{ltpdfa.getAttribute('\luaescapestring{parentattr}')}}
\edef\@ltpdfa@tattr{\directlua{ltpdfa.getAttribute('\luaescapestring{typeattr}')}}
\attributedef\@ltpdfa@typeattr=\@ltpdfa@tattr
\attributedef\@ltpdfa@parentattr=\@ltpdfa@pattr
\def\ltpdfa@last@page{\ifx\r@LTLastPage\undefined\@empty\else\expandafter\@secondoftwo\r@LTLastPage\fi}
%    \end{macrocode}
% We need the absolute last page of the document
%    \begin{macrocode}
\AfterLastShipout{\immediate\write\@mainaux{\string\newlabel{LTLastPage}{{LTLastPage}{\directlua{ltpdfa.getPageNum()}}}}}
%    \end{macrocode}
% Some macros from \lstinline{ltpdfa.sty}:
%    \begin{macrocode}
\newcommand*{\ccaAddToConfig}[2]{\directlua{ltpdfa.addToConfig('\luaescapestring{#1}','\luaescapestring{#2}')}}
\@onlypreamble\ccaAddToConfig
%    \end{macrocode}
% \begin{macro}{\ccaStructStart, \ccaStructEnd} inserts a structural
%   tag with the name \#2. Optional \#1 is the name of a forced
%   parent.
%
%   This tagging macro inserts \lstinline{\bgroup} and
%     \lstinline{\egroup} around the tagged area.
%    \begin{macrocode}
\newcommand*{\ccaStructStart}[2][]{\directlua{ltpdfa.tagger.structStart('\luaescapestring{#2}','\luaescapestring{#1}')}}
\newcommand*{\ccaStructEnd}[1]{\directlua{ltpdfa.tagger.structEnd('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccaVstructStart, \ccaVstructEnd} are the same as
%   \lstinline{\ccaStructStart} and \lstinline{\ccaStructEnd} but
%   without grouping the area.
%    \begin{macrocode}
\newcommand*{\ccaVstructStart}[2][]{\directlua{ltpdfa.tagger.vstructStart('\luaescapestring{#2}','\luaescapestring{#1}')}}
\newcommand*{\ccaVstructEnd}[1]{\directlua{ltpdfa.tagger.vstructEnd('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccaPstructStart, \ccaPstructEnd} same as
%   \lstinline{\ccaStructStart} and \lstinline{\ccaStructEnd} but no
%   grouping and not setting any attributes. Implies that the element
%   has no content children, at all.
%    \begin{macrocode}
\newcommand*{\ccaPstructStart}[2][]{\directlua{ltpdfa.tagger.pstructStart('\luaescapestring{#2}','\luaescapestring{#1}')}}
\newcommand*{\ccaPstructEnd}[1]{\directlua{ltpdfa.tagger.pstructEnd('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cca@set@docinfo} sets the PDF docinfo. \#2 is a key,
%   \#3 is the value, optional \#1 is an encoding.
%    \begin{macrocode}
\newcommand*{\ccaSetDocinfo}[3][]{\directlua{ltpdfa.setDocInfo('\luaescapestring{#2}','\luaescapestring{#3}','\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ccaAddRolemap} is used to map a custom LaTeX tag to
%   a well-defined PDF tag. \#1 is the name of the LateX Tag, \#2 is
%   the name of the PDF role.
%    \begin{macrocode}
\newcommand*{\ccaAddRolemap}[2]{\directlua{ltpdfa.tagger.addRolemap('\luaescapestring{#1}','\luaescapestring{#2}')}}
%    \end{macrocode}
% \end{macro}
%
% The local preferences for \CoCoTeX's accessibility features is done
% via the \lstinline{tpMeta} environment. Therefore, we hook the
% neccessary Components and Properties right into the
% \lstinline{titlepage} container. Therefore,
% \lstinline{coco-title.sty} is a hard requirement for \CoCoTeX's
% accessibility module:
%    \begin{macrocode}
\RequirePackage{coco-title}%
%    \end{macrocode}
%
% \subsection{Lua injection}
%
% Some features are realized by Lua code, so we tell LuaLaTeX to
% include the code that is generated from material later in this
% source file:
%    \begin{macrocode}
\directlua{ally = require('coco-accessibility')}
%    \end{macrocode}
%
% \subsection{Hyperlink handling}
%
% To tag hyperlinks, we define some ltpdfa interface macros.
%
% \begin{macro}{\ccaAddAltText} is used to add an Alternative Text
%   node, given in \#1, to the PDF structTree.
%    \begin{macrocode}
\def\ccaAddAltText#1{\directlua{ltpdfa.tagger.addAltText('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ccaAddLastLink} adds the last Link node to the PDF
%   structTree.
%    \begin{macrocode}
\def\ccaAddLastLink{\directlua{ltpdfa.tagger.addLastLink()}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ccaGetStructParent} returns the current parent
%   structure. This is needed in case a link breaks across columns (or
%   pages).
%    \begin{macrocode}
\def\ccaGetStructParent{\directlua{ltpdfa.tagger.getStructParent()}}
%    \end{macrocode}
% \end{macro}
% Now, we patch them into \lstinline{hyperref}.
%
% First we add the start tag for a Link node.
%    \begin{macrocode}
\patchcmd\Hy@StartlinkName
  {\pdfstartlink}
  {\ccaVstructStart{Link}\ccaAddAltText{#2}\edef\@ltpdfmy@parent{\ccaGetStructParent}%
   \pdfstartlink}
  {}{\cca@patch@error\Hy@StartlinkName}
%    \end{macrocode}
% and the parent node inside the link attribute:
%    \begin{macrocode}
\patchcmd\Hy@StartlinkName
  {#1}
  {#1 /StructParent \@ltpdfmy@parent}
  {}{\cca@patch@error\Hy@StartlinkName}
%    \end{macrocode}
% then we patch hyperref's general link macro, twice. Once for the Link's start tag
%    \begin{macrocode}
\patchcmd\hyper@linkurl
  {\pdfstartlink}
  {\ccaVstructStart{Link}\ccaAddAltText{#1}\edef\@ltpdfmy@parent{\ccaGetStructParent}%
   \pdfstartlink}
  {}{\cca@patch@error\hyper@linkurl}
%    \end{macrocode}
% and secondly for the Parent:
%    \begin{macrocode}
\patchcmd\hyper@linkurl
  {/C[\@urlbordercolor]%
        \fi
  }
  {/C[\@urlbordercolor]%
        \fi
        /StructParent \@ltpdfmy@parent%
  }{}{\cca@patch@error\hyper@linkurl}
%    \end{macrocode}
% finally, we patch the end tag for the link node into the
% \lstinline{\close@pdflink} macro:
%    \begin{macrocode}
\patchcmd\close@pdflink
  {\pdfendlink}
  {\pdfendlink
   \ccaAddLastLink\ccaVstructEnd{Link}}
  {}{\cca@patch@error\close@pdflink}
%    \end{macrocode}
% For internal references, we patch the tagging into the
% \lstinline{\@setref} macro. Unfortunately, hyperref redefines this
% macro and links to both the original version (when \lstinline{\ref*}
% is used), and its own re-definition (else), so we need to patch both
% versions. We start by resetting \lstinline{\@setref} to its vanilla
% state and inject our tagging:
%    \begin{macrocode}
\let\cca@hy@setref\@setref
\let\@setref\real@setref
\patchcmd\@setref
  {\expandafter#2#1\null}
  {\ccaStructStart{Reference}\expandafter#2#1\null\ccaStructEnd{Reference}}
  {}{\cca@patch@error\@setref}
%    \end{macrocode}
% Now, we restore hyperref's version and inject the tagging there as
% well:
%    \begin{macrocode}
\let\real@setref\@setref
\let\@setref\cca@hy@setref
\patchcmd\@setref
  {\expandafter\Hy@setref@link}
  {\ccaStructStart{Reference}\expandafter\Hy@setref@link}
  {}{\cca@patch@error\@setref}
\patchcmd\@setref
  {{#2}}
  {{#2}\ccaStructEnd{Reference}}
  {}{\cca@patch@error\@setref}
%    \end{macrocode}
%
% \subsection{Tagging Page Styles as Artifacts}
%
% Page styles, i.e., headers and footers need to be tagged as
% artifacts unless they contain semantic information. To avoid
% inserting the tagging by hand into each publisher's page style
% definitions, we inject the tagging automatically by using
% \lstinline{etoolbox}'s patch commands to insert the start and end
% tags inside the internal header and footer macros, respectively.
%
% \begin{macro}{\ccaPagestyleArtifacts} contains the code to patch the
%   \lstinline{\@oddhead}, \lstinline{\@evenhead},
%   \lstinline{\@oddfoot} and \lstinline{\@evenfoot} macros.
%    \begin{macrocode}
\def\ccaPagestyleArtifacts{%
  \ifx\@oddhead\@empty\else
    \pretocmd\@oddhead{\ccaStructStart[document]{header}}{}{}%
    \apptocmd\@oddhead{\ccaStructEnd{header}}{}{}%
  \fi
  \ifx\@evenhead\@empty\else
    \pretocmd\@evenhead{\ccaStructStart[document]{header}}{}{}%
    \apptocmd\@evenhead{\ccaStructEnd{header}}{}{}%
  \fi
  \ifx\@oddfoot\@empty\else
    \pretocmd\@oddfoot{\ccaStructStart[document]{footer}}{}{}%
    \apptocmd\@oddfoot{\ccaStructEnd{footer}}{}{}%
  \fi
  \ifx\@evenfoot\@empty\else
    \pretocmd\@evenfoot{\ccaStructStart[document]{footer}}{}{}%
    \apptocmd\@evenfoot{\ccaStructEnd{footer}}{}{}%
  \fi}
%    \end{macrocode}
% \end{macro}
% The \lstinline{\ccaPagestyleArtifacts} itself is patched into the
% \lstinline{\pagestyle} and \lstinline{\thispagestyle} macros, so the
% internal header and footer macros are patched whenever the pagestyle
% changes and the internal macros are themselves re-defined.
%    \begin{macrocode}
\apptocmd\pagestyle{\ccaPagestyleArtifacts}{}{}
\apptocmd\thispagestyle{\ccaPagestyleArtifacts}{}{}
%    \end{macrocode}
% Finally, we register the \lstinline{footer} and \lstinline{header}
% PDF tags as \lstinline{artifacts} with \lstinline{ltpdfa}:
%    \begin{macrocode}
\ccaAddToConfig{artifact}{header={Type:Pagination}{Subtype:Header}}
\ccaAddToConfig{artifact}{footer={Type:Pagination}{Subtype:Footer}}
%    \end{macrocode}
%
%\subsection{generic artifacts}
%
%    \begin{macrocode}
\ccaAddToConfig{artifact}{leaders={Type:Layout}}
\ccaAddToConfig{artifact}{footnoterule={Type:Layout}}
\ccaAddToConfig{artifact}{Artifact={Type:Layout}}
%    \end{macrocode}
%
% \subsection{Tagging for Floats}
%
% \subsubsection{Taggin for Figures}
%
%    \begin{macrocode}
\newcommand*{\ccaAddFigure}[7]{\directlua{ltpdfa.tagger.addFigure(
    '\luaescapestring{#1}',
    '\luaescapestring{#2}',
    '\luaescapestring{#3}',
    '\luaescapestring{#4}',
    '\luaescapestring{#5}',
    '\luaescapestring{#6}',
    '\luaescapestring{#7}')}}
%    \end{macrocode}
%
% \begin{macro}{\ccaFigureStart} injects the starting tag for images to the pdf
%    \begin{macrocode}
\newcommand*{\ccaFigureStart}[1]{\directlua{ltpdfa.tagger.figureStart('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\ccaFigureEnd} injects the ending tag for images
%    \begin{macrocode}
\newcommand*{\ccaFigureEnd}[1]{\directlua{ltpdfa.tagger.figureEnd('\luaescapestring{#1}')}}
%    \end{macrocode}
% \end{macro}
% which we add to the beginning and the end of \lstinline{graphics}
% package's \lstinline{\Ginclude@graphics} macro, respectively:
%    \begin{macrocode}
\@ifpackageloaded{grffile}
  {\pretocmd\grffile@Ginclude@graphics{\if@cc@is@final\ccaFigureStart{}\fi}{}{}%
   \apptocmd\grffile@Ginclude@graphics{\if@cc@is@final\ccaFigureEnd{}\fi}{}{}}
  {\pretocmd\Ginclude@graphics{\if@cc@is@final\ccaFigureStart{}\fi}{}{}%
   \apptocmd\Ginclude@graphics{\if@cc@is@final\ccaFigureEnd{}\fi}{}{}}

%    \end{macrocode}
% 
%    \begin{macrocode}
\apptocmd\Ginclude@@pdftex{\if@cc@is@final%
  \def\@tempa{!}%
  \ccaAddFigure{\Gin@llx}{\Gin@lly}{\Gin@urx}{\Gin@ury}
    {\ifx\Gin@scalex\@tempa\else \Gin@scalex\fi}
    {\ifx\Gin@scaley\@tempa\else \Gin@scaley\fi}
    {\ifGin@clip true\else false\fi}\fi%rwi/rhi
}{}{}
%    \end{macrocode}
%
%
% \subsection{XMP Integration}
%
% The first feature of \lstinline{coco-ally} is the integration of XMP
% meta data into the output PDF. Note that XMP integration is also a
% built-in feature of the \lstinline{coco-title} module. The following
% code provides a superior alternative to that via the
% \lstinline{ltpdfa} package.
%
% \begin{macro}{\tp@title@insert@xmp} is an override of the same macro
%   in \lstinline{coco-title.sty} (see. Sect.~\ref{sec:title:xmp}). If
%   the \lstinline{ally} document option is set, XMP inclusion is done
%   via the \lstinline{ltpdfa} package.
%
%   First we check if the specified xmp file exists. If it exists, the
%   \lstinline{DocumentInfo} is extracted from the XMP
%   file. Otherwise, we set the \lstinline{DocumentInfo} from the
%   contents of the \lstinline{titlepage} Container and let
%   \lstinline{ltpdfa} generate the \lstinline{xmp} file.
%    \begin{macrocode}
\def\cct@title@insert@xmp{%
  \edef\tp@xmp@file@name{\tpUseGComp{titlepage}{XmpFile}.xmp}%
  \IfFileExists{\tp@xmp@file@name}
    {\ccaAddToConfig{metadata}{xmpfile=\tp@xmp@file@name}%
     \directlua{ally.meta.extract()}}
    {\ccPackageWarning{A11y}{File}{%
\tp@xmp@file@name\space not found.^^J
Note that the ltpdfa package will create one^^J
from the Components given in the tpMeta Container.}}}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Output Intent and ICC Profiles}
%
%
% First, we declare some Components that represent the three necessary
% parameters for the output intent:
%    \begin{macrocode}
\tpAddToType{Components}{titlepage}{%
%    \end{macrocode}
% \begin{tpComponent}{titlepage}{IccProfileFile} holds the path
%   (relative to the main tex file) and name of the .icc file.
%    \begin{macrocode}
  \tpDeclareGComp{IccProfileFile}
%    \end{macrocode}
% \end{tpComponent}
% \begin{tpComponent}{titlepage}{IccComponents} holds the number of
%   components in the color profile
%    \begin{macrocode}
  \tpDeclareGComp{IccComponents}
%    \end{macrocode}
% \end{tpComponent}
% \begin{tpComponent}{titlepage}{IccIdentifier} holds the identifier
%   of the color profile
%    \begin{macrocode}
  \tpDeclareGComp{IccIdentifier}}
%    \end{macrocode}
% \end{tpComponent}
% The Components are composed via a new Property
% \lstinline{output-intent} which we add to \lstinline{coco-title}'s
% Properties list:
%    \begin{macrocode}
\ifdefstring\tp@color@enc{cmyk}
  {\def\cca@default@icc@comp{4}}
  {\def\cca@default@icc@comp{3}}
\ifdefstring\tp@color@enc{cmyk}
  {\def\cca@default@icc@iden{Coated FOGRA39}}
  {\def\cca@default@icc@iden{sRGB IEC61966-2.1}}
\tpAddToType{Properties}{titlepage}{%
%    \end{macrocode}
% \begin{tpProperty}{titlepage}{output-intent} sends the output
%   intent information to the ltpdfa package. It must contain of three
%   data fields:
%   \begin{description}
%   \item[profile] with the name of the to-be-embedded
%     \lstinline{.icc} file,
%   \item[componetns] with an integer telling the pdfwriter how many
%     values are coded by each color (e.g., \lstinline{4} for cmyk,
%     \lstinline{3} for rgb)
%   \item[identifier] with the identifying name of the profile (e.g.,
%     \lstinline{Coated FOGRA39} for the included cmyk
%     profile, etc.)
% \end{description}
%    \begin{macrocode}
  \tpSetProperty{output-intent}{%
    profile=\tpIfComp{IccProfileFile}{\tpUseComp{IccProfileFile}}{suppl/\tp@color@enc.icc};%
    components=\tpIfComp{IccComponents}{\tpUseComp{IccComponents}}{\cca@default@icc@comp};%
    identifier=\tpIfComp{IccIdentifier}{\tpUseComp{IccIdentifier}}{\cca@default@icc@iden}%
  }}
%    \end{macrocode}
% \end{tpProperty}
% The Component Handler which links the new Components to that
% Property is added to titlepage's \lstinline{document-meta-hook}:
%    \begin{macrocode}
\tpAddToHook[titlepage]{document-meta-hook}{\edef\x{\noexpand\ccaAddToConfig{intent}{\tpUseProperty{output-intent}}}\x}
%    \end{macrocode}
%
% \subsection{Transformation of  Typographic Unicode characters}
%
% In order for screen readers to work correctly, some unicode
% characters that mask purely typographic glyphs (e.g., ligatures)
% need to be mapped to their underlaying orthographic characters. This
% is done via pdftex's \lstinline{glyphtounicode} tables:
%    \begin{macrocode}
\protected\def\pdfglyphtounicode{\pdfextension glyphtounicode}
\input glyphtounicode
\edef\pdfgentounicode{\pdfvariable gentounicode}
\pdfgentounicode = 1
%    \end{macrocode}
%
% \subsection{Encoding of the PDF-A Conformance}
% As before, the parameters for the PDF conformity level are encoded
% via specific Components in the titlepage Container:
%    \begin{macrocode}
\tpAddToType{Components}{titlepage}{%
%    \end{macrocode}
%
% \begin{tpComponent}{PDFAID} defines the PDF/A ID (Default: 2,
%   meaning: PDF/A-2)
%    \begin{macrocode}
  \tpDeclareGComp[2]{PDFAID}%
%    \end{macrocode}
% \end{tpComponent}
% \begin{tpComponent}{PDFALevel} defines the PDF/A Level (Default: A,
%   meaning PDF/A-2A)
%    \begin{macrocode}
  \tpDeclareGComp[A]{PDFALevel}%
%    \end{macrocode}
% \end{tpComponent}
% \begin{tpComponent}{PDFUAID} defines the PDF standard (Default: 1,
%   meaning: PDF/UA-1). Use \lstinline|\tpPDFUAID{}| (i.e. set it to
%   nothing) to make the document conform to the PDF/A standard, but
%   \textbf{not} to the PDF/UA standard.
%    \begin{macrocode}
  \tpDeclareGComp[1]{PDFUAID}}%
%    \end{macrocode}
% \end{tpComponent}
% The checking if the values are valid, and the separation of the
% various parts of the standard is done via a lua script in the
% \lstinline{document-meta-hook}. The \lstinline{conformance}
% DocumentInfo nodes are only written, if \textit{neither}
% \lstinline{PDFAID}, \textit{nor} \lstinline{PDFALevel} is empty.
%    \begin{macrocode}
\tpAddToHook[titlepage]{document-meta-hook}{%
  \tpIfCompEmpty{PDFAID}{}{\tpIfCompEmpty{PDFALevel}{}{%
      \edef\x{\noexpand\ccaSetDocinfo{conformance}{%
          pdfaid=\tpUseComp{PDFAID};%
          level=\tpUseComp{PDFALevel}%
          \tpIfCompEmpty{PDFUAID}{}{;pdfuaid=\tpUseComp{PDFUAID}}}}%
      \x}}}
%    \end{macrocode}
%
% \subsection{Automatic PDF Tagging}
%
% \subsubsection{Document Root Node}
%
% The following code causes the ltpdfa package to tag the
% \lstinline{document} environmant as the structural representation's
% root node:
%    \begin{macrocode}
\tpDeclareHook[document]{cca/at/begin/document}
\AtBeginDocument{%
  \directlua{ltpdfa.beginDocument('\luaescapestring{\ltpdfa@last@page}')}
  \tpUseHook[document]{cca/at/begin/document}%
  \directlua{ltpdfa.configAutoclose()}
  \ccaVstructStart{document}%
}
\AtEndDocument{%
  \ccaVstructEnd{document}
  \directlua{ltpdfa.endDocument()}%
}
\ccaAddRolemap{document}{Document}
%    \end{macrocode}
% Finally, we hook \lstinline{ltpdfa}'s page processor into
% \lstinline{AtBeginShipoutBox}:
%    \begin{macrocode}
\AtBeginShipout{\directlua{ltpdfa.pageprocessor(tex.box["AtBeginShipoutBox"])}}%
%    \end{macrocode}
% End of {\TeX} source code.
%    \begin{macrocode}[gobble=1]
%</a11y-sty>
%    \end{macrocode}
%
%    \begin{macrocode}[gobble=1]
%<*a11y-lua>
%    \end{macrocode}
%
% \section{Lua code}
%
% \subsection{Local Variables and Tables}
%
% \lstinline{ltpdfa} is an instance of the \lstinline{ltpdfa} Lua
%   table.
%    \begin{macrocode}[language={[5.3]Lua}]
local ltpdfa = require('ltpdfa')
%    \end{macrocode}
%
% \subsection{Meta Data Extraction}
%
%
% \lstinline{meta} is a table that holds the metadata that are
% extracted from the \lstinline{\jobname.xmp} file via its
% \lstinline{extract} member.
%    \begin{macrocode}[language={[5.3]Lua}]
local meta = {
  Author = '',
  Title = '',
  Creator = '',
  Producer = '',
  Keywords = '',
%    \end{macrocode}
% The method \lstinline{meta.extract()} reads the meta data
% from the \lstinline{\jobname.xmp} and stores certain values to be
% accessed by LaTeX. This is used to fill the DocumentInfo when a xmp
% file is available during the expansion of
% \lstinline{\tp@write@pdf@meta} from the coco-title module (see
% Sect.~\ref{sect:coco-title:pdf-meta-data}).
%    \begin{macrocode}[language={[5.3]Lua}]
  extract = function ()
    local xmpfile = ltpdfa.metadata.xmphandler.fromFile(ltpdfa.config.metadata.xmpfile)
    local f = io.open(xmpfile, "r")
    local content = f:read("*all")
    f:close()


    if (content:find('<dc:title>')) then
      Title = content:gsub('.*<dc:title>[^<]*<rdf:Alt>[^<]*<rdf:li[^>]*>(.*)</rdf:li>[^<]*</rdf:Alt>[^<]*</dc:title>.*', "%1")
      -- log(">>>" .. meta.Title)
    end

    local authors
    local author = {}
    if (content:find('<dc:creator>')) then
      authors = content:gsub('.*<dc:creator>[^<]*<rdf:Seq>(.*)</rdf:Seq>[^<]*</dc:creator>.*', "%1")
      for k in string.gmatch(authors, "<rdf:li>([^>]+)</rdf:li>") do
        table.insert(author , k)
      end
      Author = table.concat(author, ', ')
    end
  end
}
%    \end{macrocode}
%
% \subsection{Public Methods}
%
% \lstinline{cocotex} is the base table that contains all public
%   methods and sub-tables available in the {\CoCoTeX}
%   framework. Here, it is defined unless it is already defined
%   elsewhere.
%    \begin{macrocode}[language={[5.3]Lua}]
if type(cocotex) ~= 'table' then
  cocotex = {}
end
%    \end{macrocode}
% \lstinline{cocotex.ally} is a globally available namespace for
%   coco-accessibility specific lua tables.
%    \begin{macrocode}[language={[5.3]Lua}]
cocotex.ally = {
  meta = meta
}
%    \end{macrocode}
%
% After loading \lstinline{coco-accessibility.lua} via the
% \lstinline[language={[5.3]Lua}]{require()} method, a
% \lstinline[language={[5.3]Lua}]{cocotex.ally} table is returned.
%    \begin{macrocode}[language={[5.3]Lua}]
return cocotex.ally
%    \end{macrocode}
% no more lua code.
%    \begin{macrocode}[gobble=1]
%</a11y-lua>
%    \end{macrocode}
